---
layout: post
title:  "LeetCode 47. Permutations II"
date:  2020-04-10
desc: "LeetCode 题目之 47. Permutations II"
keywords: "LeetCode,刷题算法,c++,LeetCode,47. Permutations II"
categories: [Algorithm]
tags: [LeetCode,算法,Python]
---
# 47. Permutations II

## 题目描述

Given a collection of numbers that might contain duplicates, return all possible unique permutations.

Example:

```s
Input: [1,1,2]
Output:
[
  [1,1,2],
  [1,2,1],
  [2,1,1]
]
```

来源：[力扣（LeetCode）](https://leetcode-cn.com/problems/permutations-ii)

## 解题思路

### 方法一：回溯+Set

本题是排列问题，需要找出给定字符串中所有元素的排列方式，但是这里所给的字符串中是包含重复字符的，也就是按照之前搜索方式去搜索的话会出现重复的结果，但是题目中已经明确说明了返回的结果是不包含重复的。

一个简单的方式是通过 Set 来保存所有的搜索结果，这样就算是存在重复的最后也不会出现在返回结果中。

#### 算法实现-Java

```java
class Solution{
    // 保存搜索结果
    private List<List<Integer>> res = new ArrayList<>();
    // 保存搜索过程
    private List<Integer> list = new ArrayList<>();
    // 当前元素是否被访问过
    private boolean[] used;
    public List<List<Integer>> permuteUnique(int[] nums){
        int n = nums.length;
        if(n<1){
            return res;
        }
        used = new boolean[n];
        dfs(nums,0);
        // 创建set保存结果
        Set<List<Integer>> set = new HashSet<>();
        for(List<Integer> l : res){
            set.add(l);
        }
        // 从set中取出元素重新保存到结果中
        res.clear();
        for(List<Integer> l : set){
            res.add(l);
        }
        return res;
    }

    public void dfs(int[] nums,int index){
        // 递归结束条件
        if(index == nums.length){
            res.add(new ArrayList(list));
            return;
        }
        // 递归逻辑
        for(int i=0;i<nums.length;i++){
            if(!used[i]){
                used[i] = true;
                list.add(nums[i]);
                dfs(nums,index+1);
                // 回溯
                used[i] = false;
                list.remove(list.size()-1);
            }
        }
    }
}
```
---
layout: post
title:  "LeetCode 86. 分隔链表"
date:  2020-02-17
desc: "LeetCode 题目之 86. 分隔链表"
keywords: "LeetCode,刷题算法,c++,LeetCode,86. 分隔链表"
categories: [Algorithm]
tags: [LeetCode,算法,Python]
---
# 分隔链表

## 题目描述

给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。

你应当保留两个分区中每个节点的初始相对位置。

示例:

```
输入: head = 1->4->3->2->5->2, x = 3
输出: 1->2->2->4->3->5
```

来源：力扣（LeetCode）

链接：[https://leetcode-cn.com/problems/partition-list](https://leetcode-cn.com/problems/partition-list)

## 解题思路

### 方法一：四指针法

#### 算法实现-Java

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode partition(ListNode head, int x) {
      // 特殊情况
      if(head==null || head.next==null){
          return head;
      }  
      // 创建一个新的头指针
      ListNode newHead = new ListNode(0);
      newHead.next = head;

      // 创建对应的指针
      ListNode pre = head;
      ListNode next = head;
      ListNode cur = head;

      // 开始遍历链表
      while(cur != null){
          // 特殊情况，链表不需要处理
          while(cur.next != null && cur.val < x && cur.next.val < x){
              cur = cur.next;
          }
          head = cur.next;
          // 寻找比x小的节点
          while(head != null && head.val>=x){
              pre = head;
              head = head.next;
          }
          // 当前节点小于x，进行节点的替换
          if(head != null && head.val<x){
              next = cur.next;
              cur.next = head;
              pre.next = head.next;
              head.next = next;
          }
          // 继续寻找下一个节点
          cur = cur.next;
      }
      // 返回头节点
      return newHead.next;
    }
}
```

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode partition(ListNode head, int x) {
      // 特殊情况
      if(head==null || head.next==null){
          return head;
      }  
      // 创建一个新的头指针
      ListNode newHead = new ListNode(0);
      newHead.next = head;

      // 创建对应的指针
      ListNode pre = head;
      ListNode next = head;
      ListNode cur = head;

      // 开始遍历链表
      while(cur != null){
          // 特殊情况，链表不需要处理
          while(cur.next != null && cur.val < x && cur.next.val < x){
              cur = cur.next;
          }
          head = cur.next;
          // 寻找比x小的节点
          while(head != null && head.val>=x){
              pre = head;
              head = head.next;
          }
          // 当前节点小于x，进行节点的替换
          if(head != null && head.val<x){
              next = cur.next;
              cur.next = head;
              pre.next = head.next;
              head.next = next;
          }
          // 继续寻找下一个节点
          cur = cur.next;
      }
      // 返回头节点
      return newHead.next;
    }
}
```

#### 算法性能分析

- 时间复杂度：O(n)
- 空间复杂度：O(1)
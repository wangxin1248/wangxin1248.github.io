---
layout: post
title:  "LeetCode 329. 矩阵中的最长递增路径"
date:  2020-07-15
desc: "LeetCode 题目之 329. 矩阵中的最长递增路径"
keywords: "LeetCode,刷题算法,Java,329. 矩阵中的最长递增路径"
categories: [Algorithm]
tags: [LeetCode,算法,Java]
---
# 矩阵中的最长递增路径

给定一个整数矩阵，找出最长递增路径的长度。

对于每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到边界外（即不允许环绕）。

示例 1:

```s
输入: nums = 
[
  [9,9,4],
  [6,6,8],
  [2,1,1]
] 
输出: 4 
解释: 最长递增路径为 [1, 2, 6, 9]。
```

示例 2:

```
输入: nums = 
[
  [3,4,5],
  [3,2,6],
  [2,2,1]
] 
输出: 4 
解释: 最长递增路径是 [3, 4, 5, 6]。注意不允许在对角线方向上移动。
```

来源：[力扣（LeetCode）](https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix)

## 题目分析

本题是一道动态规划的题目，具备递归结构以及最优子结构。因此可以从递归和动态规划两种思路进行求解。

### 方法一：记忆化搜索

使用**深度优先遍历**将矩阵的每一个位置都进行一遍遍历，然后从中找寻最长递增路径最长的结果。

为了降低递归操作过程中遇到的重叠子问题的情况，可以考虑使用**记忆化搜索**的方式将深度优先搜索的过程记录下来。

#### 算法实现-Java

```java
class Solution {
    // 上下左右
    private final int[][] dirs = {\{0,1\},\{1,0\},\{0,-1\},\{-1,0\}};
    public int longestIncreasingPath(int[][] matrix) {
        if(matrix.length < 1){
            return 0;
        }
        int n = matrix.length;
        int m = matrix[0].length;
        int res = 0;
        // 记忆化保存数组，保存在该位置上的最长递增路径的长度
        int[][] memo = new int[n][m];
        // 从每一个位置都进行一次寻找
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                res = Math.max(res,dfs(matrix,n,m,i,j,memo));
            }
        }
        // 返回最终结果
        return res;
    }
    // 深度优先搜索
    private int dfs(int[][] matrix,int n, int m, int i, int j, int[][] memo){
        // 该位置已经搜索过了
        if(memo[i][j] != 0){
            return memo[i][j];
        }
        // 开始进行深度优先遍历
        for(int[] dir : dirs){
            int x = dir[0]+i;
            int y = dir[1]+j;
            // 判断该位置是否可以访问
            if(x>=0 && x<n && y>=0 && y<m && matrix[x][y] > matrix[i][j]){
                memo[i][j] = Math.max(memo[i][j],dfs(matrix,n,m,x,y,memo));
            }
        }
        // 加上当前本节点的长度
        memo[i][j]++;
        return memo[i][j];
    }
}
```
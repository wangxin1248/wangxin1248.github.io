---
layout: post
title:  "LeetCode 312. 戳气球"
date:  2020-07-19
desc: "LeetCode 题目之 312. 戳气球"
keywords: "LeetCode,刷题算法,Java,312. 戳气球"
categories: [Algorithm]
tags: [LeetCode,算法,Java]
---
# 戳气球

## 题目描述

有 n 个气球，编号为0 到 n-1，每个气球上都标有一个数字，这些数字存在数组 nums 中。

现在要求你戳破所有的气球。如果你戳破气球 i ，就可以获得 nums[left] * nums[i] * nums[right] 个硬币。 这里的 left 和 right 代表和 i 相邻的两个气球的序号。注意当你戳破了气球 i 后，气球 left 和气球 right 就变成了相邻的气球。

求所能获得硬币的最大数量。

说明:

- 你可以假设 nums[-1] = nums[n] = 1，但注意它们不是真实存在的所以并不能被戳破。
- 0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100

示例:

```s
输入: [3,1,5,8]
输出: 167 
解释: nums = [3,1,5,8] --> [3,5,8] -->   [3,8]   -->  [8]  --> []
     coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167
```

来源：[力扣（LeetCode）](https://leetcode-cn.com/problems/burst-balloons)

## 题目思考

### 方法一：记忆化搜索

对于这道题目来说，每戳一个气球所对应的后续的结果都不一样，因此需要递归的去遍历每一种情况，每种情况对应的子问题都有可能被再次计算，因此我们可以考虑使用记忆化搜索的方法来进行求解。

但是戳一个气球之后会导致整体的数组的形式发生变化，这样的话就没有办法对整体的数组进行后续的处理。因此这道题的难点也在于此，也就是如何将题目转换为可解的状态。

对于示例来说，整个戳气球的过程如下：

```s
nums = [3,1,5,8] --> [3,5,8] -->   [3,8]   -->  [8]  --> []
coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167
```

其实我们可以将整个过程倒过来，也就是从后面开始推出来最后的结果，也就是把戳气球的过程改为初始的时候加气球。这样的话就可以将整个过程逆过来就可以很方便交由程序去控制。

因此我们定义我们的状态为：dfs(left,right)表示数组的 left 到 right 开区间所对应的结果。

为了方便表示我们将数组进行扩展，补充头和尾的1，将数组的长度扩展为n+2。

这样我们可以初始化的时候确定左右两端的数字，然后选择从整个 nums 数组中添加一个气球，组成最后的情况。然后被添加的气球将整个数组分为左右两个子问题，两个子问题又可以使用相同的思路进行求解。直到最后当 left >= right-1 的时候就表示所有的三个数字都已经找到了，就不需要在进行递归寻找了。

#### 算法实现-Java

```java
class Solution{
    public int maxCoins(int[] nums){
        if(nums.length < 1){
            return 0;
        }
        // 将原数组拷贝到新的数组中
        int n = nums.length;
        int[] vals = new int[n+2];
        vals[0] = vals[n+1] = 1;
        for(int i=1;i<n+1;i++){
            vals[i] = nums[i-1];
        }
        // 记忆化空间，保存 vals(left,right)区间内的解
        int[][] dp = new int[n+2][n+2];
        for(int i=0;i<n+2;i++){
            Arrays.fill(dp[i],-1);
        }
        // 开始进行寻找
        return dfs(vals,0,n+1,dp);
    }
    private int dfs(int[] vals,int left,int right,int[][] dp){
        // 递归结束条件
        if(left >= right-1){
            return 0;
        }
        // 该状态对应的结果已经计算过了
        if(dp[left][right] != -1){
            return dp[left][right];
        }
        // 开始随机的加气球
        for(int i=left+1;i<right;i++){
            // 添加i气球所对应的价值
            int res = vals[left]*vals[i]*vals[right];
            // 递归处理子问题
            res += dfs(vals,left,i,dp);
            res += dfs(vals,i,right,dp);
            // 寻找最优解
            dp[left][right] = Math.max(dp[left][right],res);
        }
        return dp[left][right];
    }
}
```
---
layout: post
title:  "LeetCode 102. Binary Tree Level Order Traversal"
date:  2018-12-04
desc: "LeetCode 题目之 102. Binary Tree Level Order Traversal"
keywords: "LeetCode,刷题算法,c++,LeetCode,102. Binary Tree Level Order Traversal"
categories: [Algorithm]
tags: [LeetCode,算法,C++]
---
# Binary Tree Level Order Traversal

## 题目描述

Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).

For example:

```s
Given binary tree [3,9,20,null,null,15,7],
    3
   / \
  9  20
    /  \
   15   7
return its level order traversal as:
[
  [3],
  [9,20],
  [15,7]
]
```

来源：[力扣（LeetCode）](https://leetcode-cn.com/problems/binary-tree-level-order-traversal)

## 解题思路

### 方法一：双队列

基本的二叉树层次遍历是利用 **队列** 来保存所要遍历的结点，按照队列先进先出的特性来实现层次遍历。

本题在原本基本的二叉树层次遍历的基础上对遍历结果的输出格式进行了要求，要求得使用列表，并且是按每层的结果做为一个新的列表保存到列表中去。

那么便可以使用两个队列来实现这个要求，将属于同一层的结点存放到 q1 列表中，将当前层的下一层结点保存到 q2 当中。这样，首先遍历完 q1 中的所有结点，将其做为一个列表添加到结果列表中去，之后交换 q1 和 q2，并且在将 q2 置为空，继续进行层次遍历，直到二叉树遍历完成。

#### 算法实现-C++

```cpp
#include <queue>
#include <vector> 
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> obj;
        // 边界判断
        if(!root){
            return obj;
        }
        vector<int> vec;
        // 保存当前层结点
        queue<TreeNode*> q1;
        // 保存下一层结点
        queue<TreeNode*> q2;
        q1.push(root);
        
        // 开始进行层次遍历
        while(!q1.empty()){
            TreeNode* n = q1.front();
            vec.push_back(n->val);
            q1.pop();
            // 将左结点进下一层队列
            if(n->left){
                q2.push(n->left);
            }
            // 将右结点进下一层队列
            if(n->right){
                q2.push(n->right);
            }
            // 当前层的结点都已经遍历完毕时交换两层结点并保存当前层结果
            if(q1.empty()){
                obj.push_back(vec);
                vec.clear();
                q1 = q2;
                // 将q2队列置空
                while(!q2.empty()){
                    q2.pop();
                }
            }
        }
        return obj;
    }
};
```

#### 算法性能分析

- 时间复杂度：O(n)
- 空间复杂度：O(n)

### 方法二：结构体入队列

上面的方法中为了保存节点的层次信息使用到了队列来保存该层节点的信息，等该层遍历完之后再将队列中的元素保存到最终队列中。这样的方法有些繁琐，其实可以创建一个结构体将节点的元素以及信息都包含在里面，再将其保存到队列中，这样在遍历队列的过程中就可以知道当前访问的层次了。

#### 算法时间-Java

```java
// 保存节点信息
class NodeInfo{
    TreeNode node;
    int level;
    NodeInfo(TreeNode node,int level){
        this.node = node;
        this.level = level;
    }
}
class Solution{
    public List<List<Integer>> levelOrder(TreeNode root){
        // 保存最终的结果
        List<List<Integer>> res = new ArrayList<>();
        // 特殊情况
        if(root == null){
            return res;
        }
        // 创建队列，保存根节点
        Queue<NodeInfo> queue = new LinkedList<>();
        queue.offer(new NodeInfo(root,0));
        while(!queue.isEmpty()){
            TreeNode node = queue.peek().node;
            int level = queue.peek().level;
            queue.poll();
            // 判断当前的层数，假如level和res的length相同则证明当前层正要被遍历
            if(level == res.size()){
                res.add(new ArrayList<Integer>());
            }
            // 保存当前层的数据
            res.get(level).add(node.val);
            // 加入node的孩子节点
            if(node.left != null){
                queue.offer(new NodeInfo(node.left,level+1));
            }
            if(node.right != null){
                queue.offer(new NodeInfo(node.right,level+1));
            }
        }
        return res;
    }
}
```
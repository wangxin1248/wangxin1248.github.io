---
layout: post
title:  "LeetCode 70. Climbing Stairs"
date:  2018-12-18
desc: "LeetCode 题目之 70. Climbing Stairs"
keywords: "LeetCode,刷题算法,c++,LeetCode,70. Climbing Stairs, 动态规划"
categories: [Algorithm]
tags: [LeetCode,算法,C++]
---
# Climbing Stairs

## 题目描述

You are climbing a stair case. It takes n steps to reach to the top.

Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?

Note: Given n will be a positive integer.

Example 1:

```s
Input: 2
Output: 2
Explanation: There are two ways to climb to the top.
1. 1 step + 1 step
2. 2 steps
```

Example 2:

```s
Input: 3
Output: 3
Explanation: There are three ways to climb to the top.
1. 1 step + 1 step + 1 step
2. 1 step + 2 steps
3. 2 steps + 1 step
```

来源：[力扣（LeetCode）](https://leetcode-cn.com/problems/climbing-stairs)

## 解题思路

### 方法一：动态规划

这道问题是一道经典的动态规划问题，其原理类似于斐波那契数列。我们首先根据题目的要求画出其对应的递归树的一部分：

![18](/assets/images/2018/2018-12/18.png)

根据递归树可以看出在求解 n 个台阶的问题可以拆分为很多的子问题。并且这些子问题当中还有很多的**重叠子问题**。我们将重叠的子问题首先进行表示就可以很方便的表示原问题。这也是动态规划的思考思路。

根据递归树的结构我们可以将问题与子问题之间的关系寻找到：

```java
res[n] = res[n-1] + res[n-2];//n个台阶的结果是n-1个台阶走1步或者n-2个台阶走2步来得到
```

#### 算法实现-C++

```cpp
class Solution {
public:
    int climbStairs(int n) {
        int a[n+1];
        a[0]=1;
        a[1]=1;
        for(int i=2;i<=n;i++){
            a[i]=a[i-1]+a[i-2];
        }
        return a[n];
    }
};
```

#### 算法实现-Java

```java
class Solution {
    public int climbStairs(int n) {
        int[] res = new int[n+1];
        res[0] = 1;// 一个台阶都没有只有一种走法：不走
        res[1] = 1;
        for(int i=2;i<=n;i++){
            res[i] = res[i-1]+res[i-2];
        }
        return res[n];
    }
}
```

#### 算法性能分析

- 时间复杂度：O(n)
- 空间复杂度：O(n)

---
layout: post
title:  "LeetCode 198. House Robber"
date:  2018-12-19
desc: "LeetCode 题目之 198. House Robber"
keywords: "LeetCode,刷题算法,c++,LeetCode,198. House Robber"
categories: [Algorithm]
tags: [LeetCode,算法,C++]
---
# House Robber

## 题目描述

You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.

Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.

Example 1:

```s
Input: [1,2,3,1]
Output: 4
Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
             Total amount you can rob = 1 + 3 = 4.
```

Example 2:

```s
Input: [2,7,9,3,1]
Output: 12
Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).
             Total amount you can rob = 2 + 9 + 1 = 12.
```

来源：[力扣（LeetCode）](https://leetcode-cn.com/problems/house-robber)

## 解题思路

### 方法一：递归

本题需要我们从 [0,...,n] 范围内的房子中进行访问，并最终获得的利益最大。

首先定义问题的**状态**为：考虑偷 [0,...,x] 范围内的房子的最大利益

根据对状态的定义，我们可以可以得到问题的**状态转移方程**：

```tex
f(x) = max(v(0) + f(2), v(1) + f(3), ... , v(x-2), v(x-1))
```

对于本题来说，访问 n 个房子的最大利益的状态转移方程为：

```tex
f(n) = max(v(0) + f(2), v(1) + f(3), ... , v(n-2), v(n-1))
```

根据状态转移方程可以实现相应的递归算法

#### 算法实现-Java

```java
class Solution {
    public int rob(int[] nums) {
        return tryRob(nums, 0);
    }
    // 尝试偷 [0,...,x] 范围里的房间
    private int tryRob(int[] nums, int start){
        // 递归结束条件
        if(start >= nums.length){
            return 0;
        }
        int res = 0;
        // 尝试偷取其余的房间
        for(int i=start;i<nums.length;i++){
            // 状态转移方程
            res = Math.max(res, nums[i]+tryRob(nums, i+2));
        }
        return res;
    }
}
```

### 方法二：记忆化搜索

从上面的递归树中也可以看到其中存在着很多的重叠子问题，并且这些重叠子问题还具有最优子结构的性质。而在递归的过程中会对这些子结构多次进行计算，为了优化上面的递归算法我们采用记忆化搜索的方法来优化递归过程

#### 算法实现-Java

```java
class Solution {
    public int rob(int[] nums) {
        // 记录过程结果
        int[] memo = new int[nums.length];
        Arrays.fill(memo,-1);
        return tryRob(nums, 0, memo);
    }
    // 尝试偷 [0,...,x] 范围里的房间
    private int tryRob(int[] nums, int start, int[] memo){
        // 递归结束条件
        if(start >= nums.length){
            return 0;
        }
        // 当前该子结构已经访问过了
        if(memo[start] != -1){
            return memo[start];
        }
        int res = 0;
        // 尝试偷取其余的房间
        for(int i=start;i<nums.length;i++){
            // 状态转移方程
            res = Math.max(res, nums[i]+tryRob(nums, i+2, memo));
        }
        // 记录当前结构的状态
        memo[start] = res;
        return res;
    }
}
```

### 方法三：动态规划

对于具有最优子结构和重叠子问题的题目来说还可以使用**动态规划**的方法来求解。

使用动态规划的方法的话可以将状态采用数组的方式来保存，这样状态转移方程就可以通过数组间的变换来实现。

#### 算法实现-Java

```java
class Solution {
    public int rob(int[] nums) {
        // 非法情况
        if(nums == null || nums.length == 0){
            return 0;
        }
        // 记录过程结果
        int[] memo = new int[nums.length];
        // 初始值
        memo[0] = nums[0];//只有一个房间肯定要偷
        // 开始尝试偷其他房间
        for(int i=1;i<nums.length;i++){
            // 设置不偷或者偷的最大值
            memo[i] = Math.max(memo[i-1], nums[i]+(i>1?memo[i-2]:0));
        }
        // 返回结果
        return memo[nums.length-1];
    }
}
```

#### 算法性能分析

- 时间复杂度：O(n)
- 空间复杂度：O(n)

### 方法四：进一步优化动态规划

上面的动态规划方法中使用到了一个数组来保存所有的过程结果，但是对于题目来说，只需要最后的结果，并不要求中间的计算过程。

因此我们可以使用变量来代替过程数组。

#### 算法实现-Java

```java
class Solution {
    public int rob(int[] nums) {
        // 非法情况
        if(nums == null || nums.length == 0){
            return 0;
        }
        // 只有一个房间
        if(nums.length == 1){
            return nums[0];
        }
        // 初始值
        int one = nums[0];//只有一个房间肯定要偷
        int res = Math.max(nums[0],nums[1]);//两个房间选择最大价值的
        // 开始尝试偷其他房间
        for(int i=2;i<nums.length;i++){
            int temp = res;
            // 设置不偷或者偷的最大值
            res = Math.max(res, nums[i]+one);
            one = temp;
        }
        // 返回结果
        return res;
    }
}
```

#### 算法实现-c++

```cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        if(nums.size()<=1){
            return nums.size()==0?0:nums[0];
        }
        // 上一次的最大收益
        int a = nums[0];
        // 当前的最大收益
        int b = max(nums[0],nums[1]);
        // 开始循环
        for(int i=2;i<nums.size();i++){
            int temp = b;
            b = max(nums[i]+a, b);
            a = temp;
        }
        // b为最终的最优解
        return b;
    }
};
```

#### 算法性能分析

- 时间复杂度：O(n)
- 空间复杂度：O(1)

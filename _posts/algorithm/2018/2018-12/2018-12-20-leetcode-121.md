---
layout: post
title:  "LeetCode 121. Best Time to Buy and Sell Stock"
date:  2018-12-20
desc: "LeetCode 题目之 121. Best Time to Buy and Sell Stock"
keywords: "LeetCode,刷题算法,c++,LeetCode,121. Best Time to Buy and Sell Stock"
categories: [Algorithm]
tags: [LeetCode,算法,C++]
---
# Best Time to Buy and Sell Stock

## 题目描述

Say you have an array for which the ith element is the price of a given stock on day i.

If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.

Note that you cannot sell a stock before you buy one.

Example 1:
```s
Input: [7,1,5,3,6,4]
Output: 5
Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.
             Not 7-1 = 6, as selling price needs to be larger than buying price.
```

Example 2:

```s
Input: [7,6,4,3,1]
Output: 0
Explanation: In this case, no transaction is done, i.e. max profit = 0.
```

来源：[力扣（LeetCode）](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock)

## 解题思路

### 方法一：动态规划

本题是股票系列问题之一，按照[股票问题的通用解决方法](https://wangxin1248.github.io/algorithm/2020/05/leetcode-stock.html)可以很快的写出对应的解法。

#### 算法实现-Java

```java
class Solution {
    public int maxProfit(int[] prices) {
        int n = prices.length;
        // 初始状态量
        int dp_i_0 = 0;// 第i(1)天没有持有股票的最大收益
        int dp_i_1 = Integer.MIN_VALUE;// 第i(1)天持有股票的最大收益
        // 开始执行状态转移
        for(int i=0;i<n;i++){
            dp_i_0 = Math.max(dp_i_0, dp_i_1+prices[i]);// 第i天没有持有股票的收益，可能是前一天就没有持有或者把前一天持有的在今天卖掉了
            dp_i_1 = Math.max(dp_i_1, -prices[i]);// 第i天持有股票的收益，可能前一天就已经持有了或者前一天没有持有买了今天的，只能买卖一次因此直接减去今天的价格
        }
        // 返回第n天没有持有股票的收益
        return dp_i_0;
    }
}
```

#### 算法性能分析

- 时间复杂度：O(n)
- 空间复杂度：O(1)

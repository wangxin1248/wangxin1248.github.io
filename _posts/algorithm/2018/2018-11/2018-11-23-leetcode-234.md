---
layout: post
title:  "LeetCode 234. Palindrome Linked List"
date:  2018-11-23
desc: "LeetCode 题目之 234. Palindrome Linked List"
keywords: "LeetCode,刷题算法,Python,LeetCode,234. Palindrome Linked List"
categories: [Algorithm]
tags: [LeetCode,算法,C++]
---
# Palindrome Linked List

## 题目描述

Given a singly linked list, determine if it is a palindrome.

Example 1:

```s
Input: 1->2
Output: false
```

Example 2:

```s
Input: 1->2->2->1
Output: true
```

Follow up:
- Could you do it in O(n) time and O(1) space?

来源：[力扣（LeetCode）](https://leetcode-cn.com/problems/palindrome-linked-list)

## 解题思路

### 方法一

对于这道问题来说：

```s
1->2->3->2->1->NULL
```

可以首先使用**快慢指针**寻找到链表的中间节点，然后将原先的链表分割为两部分：

```s
1->2->NULL
3->2->1->NULL
```

然后可以将第二个链表进行原地逆序操作：

```s
1->2->NULL
1->2->3->NULL
```

然后分别比较两个链表对应位置上的节点 val 是否相同，知道某一指针指向 NULL 为止。

#### 算法实现-C++

```cpp
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        // 空指针返回 true
        if(head==NULL){
            return true;
        }
        ListNode* fast=head;
        ListNode* slow=head;
        
        // 让慢指针指向中间链表
        while(fast&&fast->next!=NULL){
            fast=fast->next->next;
            slow=slow->next;
        }
        
        // 将后半部分指针逆转
        slow=reverseList(slow);
        
        // 判断是否是回文链表
        while(slow && head){
            if(head->val==slow->val){
                head=head->next;
                slow=slow->next;
            }else{
                return false;
            }
        }
        return true;
    }
// 原地逆转指针  
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* head1 = NULL;
        while(head != NULL){
            ListNode* a = head->next;
            head->next = head1;
            head1 = head;
            head = a;
        }
        return head1;
    }
};
```

#### 算法实现-Java

```java
class Solution{
    public boolean isPalindrome(ListNode head){
        // 特殊情况
        if(head == null || head.next == null){
            return true;
        }
        // 寻找链表中间节点
        ListNode newHead = findMid(head);
        // 原地逆序后半部分节点
        newHead = reverseLinkedList(newHead);
        // 比较两个链表的val
        while(head != null && newHead != null){
            // 节点的val不同
            if(head.val != newHead.val){
                return false;
            }
            head = head.next;
            newHead = newHead.next;
        }
        return true;
    }
    public ListNode findMid(ListNode head){
        ListNode slow = head;
        ListNode fast = head;
        while(fast.next != null && fast.next.next != null){
            slow = slow.next;
            fast = fast.next.next;
        }
        return slow;
    }
    public ListNode reverseLinkedList(ListNode head){
        ListNode dummyHead = null;
        ListNode pre = dummyHead;
        while(head != null){
            ListNode temp = head.next;
            head.next = pre;
            pre = head;
            head = temp;
        }
        return pre;
    }
}
```

#### 算法性能分析

- 时间复杂度：O(n)
- 空间复杂度：O(1)

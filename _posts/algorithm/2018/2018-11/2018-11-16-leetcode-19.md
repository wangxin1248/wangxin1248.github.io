---
layout: post
title:  "LeetCode 19. Remove Nth Node From End of List"
date:  2018-11-16
desc: "LeetCode 题目之 19. Remove Nth Node From End of List"
keywords: "LeetCode,刷题算法,Python,LeetCode,19. Remove Nth Node From End of List"
categories: [Algorithm]
tags: [LeetCode,算法,C++]
---
# Remove Nth Node From End of List

## 题目描述

Given a linked list, remove the n-th node from the end of list and return its head.

Example:

```s
Given linked list: 1->2->3->4->5, and n = 2.

After removing the second node from the end, the linked list becomes 1->2->3->5.
```

Note:

- Given n will always be valid.

Follow up:

- Could you do this in one pass?

来源：[力扣（LeetCode）](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list)

## 解题思路

### 方法一

这道题主要的难点在于得分多种情况进行判断，对于删除头节点、尾节点、单独节点都得进行相应的判断。做好这些判断之后这道题也就是按部就班的做了。

其实删除倒数第 n 个节点的问题也就是创建两个不同的指针，两个指针相差 n 位而已。

#### 算法实现-Cpp

```cpp
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        // 只有一个节点的情形
        if(head->next == NULL){
            return NULL;
        }
        // 创建两个指针，a遍历链表，b指向待删节点的前一个节点
        ListNode *a,*b;
        a = head;
        int s = 0;
        while(a->next != NULL){
            a = a->next;
            s ++;
            if(s == n){
                b = head;
            }
            if(s > n){
                b = b->next;
            }
        }
        // 删除头节点的情况
        if(s+1 == n){
            head = head->next;
        }else{
        // 删除非头节点的情况
            // 删除非尾节点的情况
            if(b->next->next != NULL){
                b->next = b->next->next;
            }else{
            // 删除尾节点
                b->next = NULL;
            }
        }
        return head;
    }
};
```

#### 算法性能分析

- 时间复杂度：O(n)
- 空间复杂度：O(1)

### 方法二

上面的方法对于一些特殊情况的判断过多，这里可以通过创建一个虚拟头节点便可以无需单独处理这些特殊情况。

#### 算法实现-Java

```java
class Solution{
    public ListNode removeNthFromEnd(ListNode head,int n){
        // 特殊情况
        if(head == null){
            return head;
        }
        // 创建虚拟头节点
        ListNode dummyHead = new ListNode(0);
        dummyHead.next = head;
        // 创建指针
        ListNode p = dummyHead;
        ListNode q = dummyHead;
        // q移动n+1步
        for(int i=0;i<n+1;i++){
            q = q.next;
        }
        // q移动到最后一个节点
        while(q != null){
            q = q.next;
            p = p.next;
        }
        // 删除节点
        p.next = p.next.next;
        // 返回结果
        return dummyHead.next;
    }
}
```

#### 算法性能分析

- 时间复杂度：O(n)
- 空间复杂度：O(1)

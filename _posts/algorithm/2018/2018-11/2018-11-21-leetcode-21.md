---
layout: post
title:  "LeetCode 21. Merge Two Sorted Lists"
date:  2018-11-21
desc: "LeetCode 题目之 21. Merge Two Sorted Lists"
keywords: "LeetCode,刷题算法,Python,LeetCode,21. Merge Two Sorted Lists"
categories: [Algorithm]
tags: [LeetCode,算法,C++,Java]
---
# Merge Two Sorted Lists

## 题目描述

Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.

Example:

```s
Input: 1->2->4, 1->3->4
Output: 1->1->2->3->4->4
```

来源：[力扣（LeetCode）](https://leetcode-cn.com/problems/merge-two-sorted-lists)

## 解题思路

### 方法一：创建新链表

将两个有序链表合并为一个新的有序链表最简单的方式是新建一个新的链表，分别使用三个 **指针**来指向这三个链表，将 l1 和 l2 链表中较小值的节点加入到 l3 中，之后继续进行遍历。

由于链表本身已经有序，因此在给 l3 中添加节点的时候到最后肯定 l1 或者 l2 还会有剩余的链表没有被遍历完，最后的时候只需将剩余的链表全部加入到 l3 链表的后面就可以了。

注意：因为在创建 l3 链表的时候创建了一个头节点，而这个头节点并没有存放有用的数值，因此在最后返回的时候只需返回除了头节点之外的剩余链表。

#### 算法实现-cpp

```c++
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        // 建立一个新的节点
        ListNode* l3 = new ListNode(0);

        // 创建三个指针分别指向l1 l2 l3
        ListNode *a,*b,*c;
        a = l1;
        b = l2;
        c = l3;

        // 当l1 和 l2 中都还有节点没有被遍历到的时候将较小的节点加入到l3中
        while(a!=NULL && b!=NULL){
            if(a->val<b->val){
                c->next = a;
                a = a->next;
                c = c->next;
            }else{
                c->next = b;
                b = b->next;
                c = c->next;
            }
        }

        // 假如 l1 中还有节点未被遍历，将 l1 中所有的节点都加入到 l3 中
        if(a != NULL){
            c->next = a;
        }
        // 假如 l2 中还有节点未被遍历，将 l2 中所有的节点都加入到 l3 中
        if(b != NULL){
            c->next = b;
        }
        // 返回 l3，不包含头节点
        return l3->next;
    }
};
```

#### 算法实现-java

```java
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        // 创建l3链表
        ListNode l3 = new ListNode(0);
        // 创建指针
        ListNode cur = l3;

        // 将l1和l2中较小的节点加入到l3中
        while(l1 != null && l2 != null){
            if(l1.val <= l2.val){
                cur.next = l1;
                l1 = l1.next;
            }else{
                cur.next = l2;
                l2 = l2.next;
            }
            cur = cur.next;
        }
        // 将剩余的l1以及l2加入到l3
        while(l1 != null){
            cur.next = l1;
            l1 = l1.next;
            cur = cur.next;
        }
        while(l2 != null){
            cur.next = l2;
            l2 = l2.next;
            cur = cur.next;
        }

        // 返回最后的结果
        return l3.next;
    }
}
```

#### 算法性能分析

- 时间复杂度：O(n)
- 空间复杂度：O(n)

### 方法二：递归实现

既然两个链表已经有序了，那么将其合并为一个有序链表的操作是在重复进行如下的步骤：

首先比较 l1 和 l2 所指向的节点谁比较小，这里两个相等，则可以将 l1 所指向的节点作为新链表的首节点，之后来判断 l1.next 和 l2 所指向节点的大小。所以说在合并两个有序链表的过程中就是一直按照这个逻辑比较两个指针所指向的节点的 val 的大小。既然这样我们可以使用**递归**来实现这个步骤。

```s
1->2->4
|
l1
1->3->4
|
l2
```

#### 算法实现-Java

```java
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if(l1 == null){
            return l2;
        }
        if(l2 == null){
            return l1;
        }
        if(l1.val <= l2.val){
            l1.next = mergeTwoLists(l1.next,l2);
            return l1;
        }else{
            l2.next = mergeTwoLists(l1,l2.next);
            return l2;
        }
    }
}
```

#### 算法性能分析

- 时间复杂度：O(n)
- 空间复杂度：O(1)

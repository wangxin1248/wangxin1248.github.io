---
layout: post
title:  "LeetCode 98. Validate Binary Search Tree"
date:  2018-11-30
desc: "LeetCode 题目之 98. Validate Binary Search Tree"
keywords: "LeetCode,刷题算法,C++,LeetCode,98. Validate Binary Search Tree"
categories: [Algorithm]
tags: [LeetCode,算法,C++]
---
# Validate Binary Search Tree

## 题目描述

Given a binary tree, determine if it is a valid binary search tree (BST).

Assume a BST is defined as follows:

- The left subtree of a node contains only nodes with keys less than the node's key.
- The right subtree of a node contains only nodes with keys greater than the node's key.
- Both the left and right subtrees must also be binary search trees.
 

Example 1:

```s
    2
   / \
  1   3

Input: [2,1,3]
Output: true
```

Example 2:

```s
    5
   / \
  1   4
     / \
    3   6

Input: [5,1,4,null,null,3,6]
Output: false
Explanation: The root node's value is 5 but its right child's value is 4.
```

来源：[力扣（LeetCode）](https://leetcode-cn.com/problems/validate-binary-search-tree)

## 解题思路

### 方法一：中序遍历

可以按照二叉搜索树的性质来做这道题，

对于二叉搜索树来说其满足 **左<根<右**。那么便可以通过中序遍历这棵树，将结果保存到数组中去，最后来判断这个数组是否是有序数组即可。

#### 算法实现-C++

```cpp
class Solution {
    int a[100000];
    int i = 0;
public:
    bool isValidBST(TreeNode* root) {
        inorder(root);
        for(int j=1;j<i;j++){
            if(a[j-1]>=a[j]){
                return false;
            }
        }
        return true;
    }
    /*中序遍历*/
    void inorder(TreeNode* root){
        if(root){
            inorder(root->left);
            a[i++] = root->val;
            inorder(root->right);
        }
    }
};
```

#### 算法性能分析

- 时间复杂度：O(n)
- 空间复杂度：O(n)

### 方法二：递归

二分搜索树本身符合递归的性质，因此可以考虑使用递归的方式来求解这道问题。

对于任意一个节点都递归的去判断他是否满足 BST 的性质即可。

对于根节点的左子树中的所有节点都要求每一个节点的 val 都小于 root 的 val，根节点的右子树中的所有节点的 val 都要求大于 root 的 val。并且左右子树中的任意一个节点也都满足这个要求。

但是只使用上述操作对树进行判断的话可能会出现某一子树符合要求但是却不满足这个树根节点的要求，也就是在进行递归判断的时候还得将当前节点所对应的上下界找到。该节点不仅得满足和左右子节点的要求，还得满足其**上下界**的要求。

对于一颗子树来说，其左子树中所有的节点的上界就是根节点，右子树中所有节点的下界也是根节点。按照这个定义递归的进行下去就会找到所有节点所对应的在树中的上下界。这样按照上下界的定义只要整颗树满足的话则就为一颗二叉搜索树。

#### 算法实现-Java

```java
class Solution{
    public boolean isValidBST(TreeNode root){
        // 对于当前根节点来说，上下界都不存在
        return helper(root,null,null); 
    }
    // node 为所判断节点，floor为当前节点的下界（若存在），ceil为当前节点的上界（若存在）
    public boolean helper(TreeNode node,TreeNode floor,TreeNode ceil){
        if(node == null){
            return true;
        }
        // 判断当前节点是否满足上下界
        int val = node.val;
        if(floor != null && val <= floor.val) return false;
        if(ceil != null && val >= ceil.val) return false;
        // 判断左右子树是否满足上下界
        if(!helper(node.left,floor,node)) return false;
        if(!helper(node.right,node,ceil)) return false;
        // 当前节点满足要求
        return true;
    }
}
```

#### 算法性能分析

- 时间复杂度：O(n)：每一个节点都遍历了一次
- 空间复杂度：O(n)：对整颗树进行了处理

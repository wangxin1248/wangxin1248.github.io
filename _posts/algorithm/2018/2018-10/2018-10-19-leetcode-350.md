---
layout: post
title:  "LeetCode 350. Intersection of Two Arrays II"
date:  2018-10-19
desc: "LeetCode 题目之 350. Intersection of Two Arrays II"
keywords: "LeetCode,刷题,算法,Python,LeetCode,350. Intersection of Two Arrays II"
categories: [Algorithm]
tags: [LeetCode,算法,Python]
---
# Intersection of Two Arrays II

## 题目描述

Given two arrays, write a function to compute their intersection.

Example 1:

```s
Input: nums1 = [1,2,2,1], nums2 = [2,2]
Output: [2,2]
Example 2:

Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
Output: [4,9]
```
Note:

Each element in the result should appear as many times as it shows in both arrays.
The result can be in any order.

Follow up:

- What if the given array is already sorted? How would you optimize your algorithm?
- What if nums1's size is small compared to nums2's size? Which algorithm is better?
- What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?

来源：[力扣（LeetCode）](https://leetcode-cn.com/problems/intersection-of-two-arrays-ii)

## 解题思路

### 方法一

结合题目所给的信息，我们可以了解到假如数组是有序的话解题更方便。因此，我们首先得将数组进行排序，将数组变成有序的。

接下来得计算两个数组的长度，假如 nums1 的长度为 m ，nums2 的长度为 n。

为了保存最后所求的数组，我们得创建一个 sums3 空数组。

接下来分别用指针 i 和 j 分别指向数组 nums1 和 nums2 的开头，当 i j 还没有角标越界的时候执行下面的操作：

- i j角标下的内容相同，说明是交集元素，保存到 nums3 中，i j 分别向后加一；
- i 角标下的元素比 j 大，此时说明 nums1 中的数据都比 nums2 大，此时让 j 向后加一，找到 nums2 与 nums1 相同大的元素；
- i 角标下的元素比 j 小，此时说明 nums2 中的数据都比 nums1 大， 此时让 i 向后加一，找到 nums1 与 nums2 相同大的元素；

上述操作结束之后，nums3 中保存的数据便是 nums1 和 nums2 中的交集元素。

#### 算法实现-Python

```python
class Solution:
    def intersect(self, nums1, nums2):
        """
        :type nums1: List[int]
        :type nums2: List[int]
        :rtype: List[int]
        """
        nums3 = []
        nums1.sort()
        nums2.sort()
        m = len(nums1)
        n = len(nums2)
        i = 0
        j = 0
        while i<m and j<n:
            if nums1[i] == nums2[j]:
                nums3.append(nums1[i])
                i += 1
                j += 1
            elif nums1[i] > nums2[j]:
                j += 1
            else:
                i += 1
        return nums3
```

#### 算法实现-Java

```java
class Solution {
    public int[] intersect(int[] nums1, int[] nums2) {
        List<Integer> list = new ArrayList<>();
        int m = nums1.length;
        int n = nums2.length;
        // 排序
        Arrays.sort(nums1);
        Arrays.sort(nums2);
        // 遍历
        int i = 0,j = 0;
        while(i<m && j<n){
            if(nums1[i] == nums2[j]){
                list.add(nums1[i]);
                i++;
                j++;
            }else if(nums1[i] > nums2[j]){
                j++;
            }else{
                i++;
            }
        }
        // 返回结果
        int[] res = new int[list.size()];
        for(i=0;i<list.size();i++){
            res[i] = list.get(i);
        }
        return res;
    }
}
```

#### 算法性能分析

- 时间复杂度：O(nlogn)
- 空间复杂度：O(n)

### 方法二

- 首先将数组 nums1 和 nums2 进行排序
- 创建一个集合来存储两个数组的交集
- 将两个数组中相同的元素保存到集合中
- 最后将集合转为数组返回

#### 算法实现-Java

```java
import java.util.Arrays;
import java.util.ArrayList;

class Solution {
    public int[] intersect(int[] nums1, int[] nums2) {
        // 定义集合来存储交集
        ArrayList<Integer> nums3 = new ArrayList<Integer>();
        // 对nums1和nums2进行排序
        Arrays.sort(nums1);
        Arrays.sort(nums2);
        int i=0,j=0,k=0,m=nums1.length,n=nums2.length;
        // 将nums1和nums2中相同的元素保存到集合中
        while(i<m&&j<n){
            if(nums1[i]==nums2[j]){
                nums3.add(nums1[i]);
                i++;
                j++;
            }else if(nums1[i] > nums2[j]){
                j++;
            }else{
                i++;
            }
        }
        // 将集合变为数组
        int[] nums4 = new int[nums3.size()];
        for(int s=0;s<nums3.size();s++){
            nums4[s] = nums3.get(s);
        }
        return nums4;
    }
}
```

#### 算法性能分析

- 时间复杂度：O(nlogn)
- 空间复杂度：O(1)

### 方法三

可以通过 map 对 nums1 中的元素出现的次数进行统计，然后在遍历 nums2 的过程中判断该元素是不是在 nums1 中出现过，出现的话就是两个数组的交集元素。

#### 算法实现-Java

```java
class Solution {
    public int[] intersect(int[] nums1, int[] nums2) {
        // 使用map保存nums1中出现的元素及其次数
        Map<Integer, Integer> record = new HashMap<>();
        for(int i=0;i<nums1.length;i++){
            record.put(nums1[i], record.getOrDefault(nums1[i],0)+1);
        }
        // 获取nums2中出现在record中的元素
        List<Integer> res = new ArrayList<>();
        for(int i=0;i<nums2.length;i++){
            if(record.containsKey(nums2[i]) && record.get(nums2[i]) > 0){
                res.add(nums2[i]);
                record.put(nums2[i], record.get(nums2[i])-1);
            }
        }
        // 生成结果
        int[] result = new int[res.size()];
        for(int i=0;i<res.size();i++){
            result[i] = res.get(i);
        }
        return result;
    }
}
```

#### 算法性能分析

- 时间复杂度：O(n)
- 空间复杂度：O(n)
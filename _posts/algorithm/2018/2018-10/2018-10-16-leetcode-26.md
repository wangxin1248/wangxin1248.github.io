---
layout: post
title:  "LeetCode 26. Remove Duplicates from Sorted Array"
date:  2018-10-16
desc: "LeetCode 题目之 26. Remove Duplicates from Sorted Array"
keywords: "LeetCode,刷题,算法,C++,26. Remove Duplicates from Sorted Array"
categories: [Algorithm]
tags: [LeetCode,算法,C++]
---
# Remove Duplicates from Sorted Array

## 问题描述

Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.

Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.

Example 1:

```s
Given nums = [1,1,2],

Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.

It doesn't matter what you leave beyond the returned length.
```

Example 2:

```s
Given nums = [0,0,1,1,1,2,2,3,3,4],

Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.

It doesn't matter what values are set beyond the returned length.
```

Clarification:

Confused why the returned value is an integer but your answer is an array?

Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well.

Internally you can think of this:

```java
// nums is passed in by reference. (i.e., without making a copy)
int len = removeDuplicates(nums);

// any modification to nums in your function would be known by the caller.
// using the length returned by your function, it prints the first len elements.
for (int i = 0; i < len; i++) {
    print(nums[i]);
}
```

来源：[力扣（LeetCode）](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array)

## 解题思路

### 方法一

首先这个题目是要求在原数组的基础上删除相同的元素，其实这个问题比较简单。也就是基本的判断两个元素是否相同的问题，只不过判断的时候这两个元素是动态变化的。假如两个元素相同的情况下，就得 **用后一个元素来覆盖前一个元素**。这样便可以实现在原数组的基础上实现去重。

但是值得注意的是，因为是要对原数组直接进行操作，所以说所需要处理的数组的长度是动态变化的。所以在循环的过程中，要随着去掉元素也得改变所要遍历的长度。

比如说，一开始先进行判断第一个元素和第二个元素是否相同。这时就分为相同和不相同两种情况，相同的情况下的话就得从这个元素的位置开始用后一个元素来覆盖前一个元素，覆盖完之后数组的长度变为之前的长度-1。此时，依旧还得判断第一个元素和第二个元素是否相同，假如相同则继续。假如一开始判断到第一个和第二个不相同的话，就得去判断第二个和第三个是否相同。相同的话就从后往前覆盖但是还是继续判断第二个和第三个。也就是说只有前后两个元素不相同的情况下执行判断的角标才会往后移动。

这道题目中需要特殊注意的几个点是：

- 对数组迭代的范围是从0 到 数组长度-删掉元素的个数-1；
- 一开始得保存数组的原始长度以及每次删除的元素的个数；
- 可能存在连续相同元素的情况，所以说只有不相同时才会判断下一个位置，相同时一直判断该位置；
- 最后返回的是数组的原始长度-删除元素个数；

#### 算法实现-C++

```c++
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int len = nums.size();
        int count = 0;
        for(int i=0;i<(len-count-1);){
            if(nums[i]==nums[i+1]){
                for(int j=i;j<(len-count);j++){
                    nums[j] = nums[j+1];
                }
                count++;
            }else{
                i++;
            }
        }
        return len-count;
    }
};
```

#### 算法性能分析

- 时间复杂度：O(n^2)
- 空间复杂度：O(1)

### 方法二：双指针法

上面的方法时间复杂度较高，可以对其进行相应的优化，这里采用**双指针法**。

这里创建两个指针 ans 和 i，ans 指向 角标为1的元素，i 也指向0（因为第一个元素是不重复的，ans指向的位置是当前存放答案元素的位置，也就是目前 ans 之前的元素都是不含重复元素的，i 用来寻找一个答案元素）。当 i 与 i+1 位置的元素值不同时便是寻找到一个答案元素，将 i+1 位置的元素与 ans 位置下的元素进行**交换**，并且 ans++。然后继续寻找下一个 i 指向的元素。最后返回 ans 就是不含重复元素的数组长度。

#### 算法实现-Java

```java
class Solution {
    public int removeDuplicates(int[] nums) {
        int ans = 1;
        int n = nums.length;
        for(int i=1;i<n;i++){
            if(nums[i] != nums[i-1]){
                if(i > ans) {
                    // i与ans指向不同元素才进行交换
                    nums[i] ^= nums[ans];
                    nums[ans] ^= nums[i];
                    nums[i] ^= nums[ans];
                    if (i < (n - 1) && nums[ans] == nums[i + 1]) i++;
                }
                // i与ans相同或者i已经与ans交换之后都需要将ans++
                ans++;
            }
        }
        return ans;
    }
}
```

#### 算法性能分析

- 时间复杂度：O(n)
- 空间复杂度：O(1)

### 方法三：优化双指针

方法二虽然已经将时间复杂度降到了 O(n)，但是由于使用到了 **交换两个元素**（一次交换操作相当于三次赋值操作），因此显得代码比较臃肿。可以将交换的操作改为 **赋值** 来简化代码。

具体来说，还是使用 ans 来指向当前需要改变值的位置，然后使用 i 来寻找合适的元素赋值给 ans 即可。首先 ans 指向 0，i 从1开始寻找，当 ans 下的元素和 i 下的元素不同时，则让 ans +1 之后将 i 下的元素赋值给 ans，之后继续进行循环。最后返回 ans+1；

#### 算法实现-Java

```java
class Solution {
    public int removeDuplicates(int[] nums) {
        int n = nums.length;
        // 特殊情况
        if(n<=1){
            return n;
        }
        int ans = 0;
        for(int i=1;i<n;i++){
            if(nums[ans] != nums[i]){
                nums[++ans] = nums[i];
            }
        }
        return ++ans;
    }
}
```

#### 算法性能分析

- 时间复杂度：O(n)
- 空间复杂度：O(1)

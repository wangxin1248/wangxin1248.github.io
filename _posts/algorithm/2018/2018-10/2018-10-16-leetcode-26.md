---
layout: post
title:  "LeetCode 26.删除排序数组中的重复项"
date:  2018-10-16
desc: "LeetCode 题目之 26.删除排序数组中的重复项"
keywords: "LeetCode,刷题,算法,C++,删除排序数组中的重复项"
categories: [Algorithm]
tags: [LeetCode,算法,C++]
---
# 删除排序数组中的重复项

## 问题描述

给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。

不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。

示例 1:

给定数组 nums = [1,1,2], 

函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 

你不需要考虑数组中超出新长度后面的元素。<br/>
示例 2:<br/>

给定 nums = [0,0,1,1,1,2,2,3,3,4],

函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。

你不需要考虑数组中超出新长度后面的元素。<br/>
说明:<br/>

为什么返回数值是整数，但输出的答案是数组呢?

请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。

你可以想象内部操作如下:<br/>

```c++
// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
int len = removeDuplicates(nums);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。
for (int i = 0; i < len; i++) {
    print(nums[i]);
}
```

## 解题思路

### 方法一

首先这个题目是要求在原数组的基础上删除相同的元素，其实这个问题比较简单。也就是基本的判断两个元素是否相同的问题，只不过判断的时候这两个元素是动态变化的。假如两个元素相同的情况下，就得 **用后一个元素来覆盖前一个元素**。这样便可以实现在原数组的基础上实现去重。

但是值得注意的是，因为是要对原数组直接进行操作，所以说所需要处理的数组的长度是动态变化的。所以在循环的过程中，要随着去掉元素也得改变所要遍历的长度。

比如说，一开始先进行判断第一个元素和第二个元素是否相同。这时就分为相同和不相同两种情况，相同的情况下的话就得从这个元素的位置开始用后一个元素来覆盖前一个元素，覆盖完之后数组的长度变为之前的长度-1。此时，依旧还得判断第一个元素和第二个元素是否相同，假如相同则继续。假如一开始判断到第一个和第二个不相同的话，就得去判断第二个和第三个是否相同。相同的话就从后往前覆盖但是还是继续判断第二个和第三个。也就是说只有前后两个元素不相同的情况下执行判断的角标才会往后移动。

这道题目中需要特殊注意的几个点是：

- 对数组迭代的范围是从0 到 数组长度-删掉元素的个数-1；
- 一开始得保存数组的原始长度以及每次删除的元素的个数；
- 可能存在连续相同元素的情况，所以说只有不相同时才会判断下一个位置，相同时一直判断该位置；
- 最后返回的是数组的原始长度-删除元素个数；

#### C++实现

```c++
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int len = nums.size();
        int count = 0;
        for(int i=0;i<(len-count-1);){
            if(nums[i]==nums[i+1]){
                for(int j=i;j<(len-count);j++){
                    nums[j] = nums[j+1];
                }
                count++;
            }else{
                i++;
            }
        }
        return len-count;
    }
};
```

#### 算法性能分析

- 时间复杂度：O(n^2)
- 空间复杂度：O(1)

### 方法二：双指针法

上面的方法时间复杂度较高，可以对其进行相应的优化。

对于需要处理的数组来说，可以用 i 指针指向1， ans 指针指向0，当两个指针下的值不同时便进行交换，交换完成之后将 ans++，并且假如原先 i 指针和 i+1 指针位置的元素一致，那么便不需要再继续判断 i+1 位置的元素了，因此可以直接跳过 i+1。最终返回 ans。

#### Java实现

```java
class Solution {
    public int removeDuplicates(int[] nums) {
        int ans = 1;
        int n = nums.length;
        for(int i=1;i<n;i++){
            if(nums[i] != nums[i-1]){
                if(i > ans) {
                    // i与ans指向不同元素才进行交换
                    nums[i] ^= nums[ans];
                    nums[ans] ^= nums[i];
                    nums[i] ^= nums[ans];
                    if (i < (n - 1) && nums[ans] == nums[i + 1]) i++;
                }
                // i与ans相同或者i已经与ans交换之后都需要将ans++
                ans++;
            }
        }
        return ans;
    }
}
```

#### 算法性能分析

- 时间复杂度：O(n)
- 空间复杂度：O(1)

### 方法二简化

方法二虽然已经将时间复杂度降到了 O(n)，但是由于使用到了 **交换两个元素**，因此显得代码比较臃肿。可以将交换的操作改为 **赋值**来简化代码

#### Java实现

```java
class Solution {
    public int removeDuplicates(int[] nums) {
        int ans = 0;
        int n = nums.length;
        for(int i=1;i<n;i++){
            if(nums[ans] != nums[i]){
                ans++;
                nums[ans] = nums[i];
            }
        }
        return ans+1;
    }
}
```

#### 算法性能分析

- 时间复杂度：O(n)
- 空间复杂度：O(1)
---
layout: post
title:  "LeetCode 9. Palindrome Number"
date:  2018-10-15
desc: "LeetCode 题目之 9. Palindrome Number"
keywords: "LeetCode,刷题,算法,C++,9. Palindrome Number"
categories: [Algorithm]
tags: [LeetCode,算法,C++]
---
# Palindrome Number

## 题目描述

Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.

Example 1:

```s
Input: 121
Output: true
```

Example 2:

```s
Input: -121
Output: false
Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.
```

Example 3:

```s
Input: 10
Output: false
Explanation: Reads 01 from right to left. Therefore it is not a palindrome.
```

Follow up:

- Coud you solve it without converting the integer to a string?

来源：[力扣（LeetCode）](https://leetcode-cn.com/problems/palindrome-number)

## 解题思路

### 方法一：翻转一半原数字

首先得知道什么是回文数，也就是对于一个数从头到尾和从尾到头是一个数，那么首先可以得到的结论便是这个是是非负的，因为非负数并不能反过来形成一个数。

所以说我们判断这个数是回文数的范围就缩小到了正数和0上了，而且正数和0是同一种处理方式。因此我们便回到最初的回文数的定义上来看，既然他定义说了要将数据反过来，那么便可以将其反过来形成一个新的数字。

那么，如何将一个数字反过来便成为了这道题的真正难点。

我们知道，取一个数字的最后一位是让这个数字 **对10取模**，而去掉这个数字的最后一位的方法是将这个数字 **除以10**，这样我们不停的 对10取膜和除以10 便会将这个数字从尾到头所有的位全部取出来，再将取出来的这些位每一位都 **乘10再加上下一位**。这样新形成的这个数便是原先的那个数反过来的样子。

最后在让新形成的数和之前传入的那个数进行比较即可。

但是上面的方法会存在翻转之后的数字超过整数范围，也就是出现整数溢出问题。

因此我们可以考虑**翻转一半数字**。既然是回文数那么翻转一半的数字和之前的数字肯定是相同的，这时问题的重点便变为如何判断将数字已经翻转了一半：

当原数字小于翻转的数字的时候就处理超过一半的数字了。

此时两个数字还不相等则就不是回文数。

#### 算法实现-Java

```java
class Solution{
    public boolean isPalindrome(int x){
        // x为负数、10的整数并且还不是0的都不是回文数
        if(x<0 || (x%10==0&&x!=0)){
            return false;
        }else{
            int y = 0;
            // x大于y的情况下可以继续翻转数字
            while(x>y){
                y = y*10+x%10;
                x = x/10;
            }
            if(x == y || x == y/10){
                return true;
            }
            return false;
        }
    }
}
```

#### 算法性能分析

- 时间复杂度：O(log10(n))
- 空间复杂度：O(1)

---
layout: post
title:  "LeetCode 189. Rotate Array"
date:  2018-10-17
desc: "LeetCode 题目之 189. Rotate Array"
keywords: "LeetCode,刷题,算法,Python,LeetCode,189. Rotate Array"
categories: [Algorithm]
tags: [LeetCode,算法,Python]
---
# Rotate Array

## 题目描述

Given an array, rotate the array to the right by k steps, where k is non-negative.

Example 1:

```s
Input: [1,2,3,4,5,6,7] and k = 3
Output: [5,6,7,1,2,3,4]
Explanation:
rotate 1 steps to the right: [7,1,2,3,4,5,6]
rotate 2 steps to the right: [6,7,1,2,3,4,5]
rotate 3 steps to the right: [5,6,7,1,2,3,4]
```

Example 2:

```s
Input: [-1,-100,3,99] and k = 2
Output: [3,99,-1,-100]
Explanation: 
rotate 1 steps to the right: [99,-1,-100,3]
rotate 2 steps to the right: [3,99,-1,-100]
```

Note:

Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.

Could you do it in-place with O(1) extra space?

来源：[力扣（LeetCode）](https://leetcode-cn.com/problems/rotate-array)

## 解题思路

### 方法一

首先读完题目就可以知道这道题的基本意思就是说是将一个数组的元素向右循环移动，而且这个移动是在本数组之内进行的，有点类似循环数组的概念。

首先，一步步分析：

先进行向右移动一位

[1,2,3,4,5,6,7] -> [7,1,2,3,4,5,6]

再移动一位

[7,1,2,3,4,5,6] -> [6,7,1,2,3,4,5]

再移动一位：

[6,7,1,2,3,4,5] -> [5,6,7,1,2,3,4]

可以看出，每移动一位都是基本的 **最后一位取出，在从尾到头将前一个元素放到后一个元素的位置上，最后将最后一个元素放到第一位上**

按照这个思路编写代码，提交发现 **最后一个测试用例超时**，那么就可以明确肯定不是使用这种方法来解题的。

既然一步步来处理问题不是解题方法，那么我们这次来直接观察移动前和移动后的数据：

[1,2,3,4,5,6,7] -> [5,6,7,1,2,3,4]

可以看到，5 6 7 三个比较大的数反而在 1 2 3 4 这几个比较小的数之前，并且都是有序的。

首先为了实现 5 6 7 位于 1 2 3 4 之前肯定得对数组进行相应的处理，这个处理就是 **逆序**

[1,2,3,4,5,6,7] -> [7,6,5,4,3,2,1]

好了，现在 5 6 7 确实在 1 2 3 4的前面了，但是确实逆序的，因此我们需要 **分别对 7 6 5 和 4 3 2 1在进行一次逆序操作**。这样就得到结果了。

也就是说得编写一个函数能够满足对数组指定区间的数据实现逆序操作，并且分别调用这个函数三次：第一次区间为 **0 到 length-1**；第二次区间为 **k 到 length-1**；第三次区间为 **0 到 k-1**。

**注意：还有一个问题就是移动的位数k可能会比数组的长度还要多**，这种情况就得分析一下：

首先，假如数组的长度是 n 那么假如需要将这个数组向右移动 n的整数倍 个位置的话，其实结果还是原来的那个数组。

比如：[1,2,3] 向右移动3位

第一位移动：

[1,2,3] -> [3,1,2]

第二位移动：

[3,1,2] -> [2,3,1]

第三位移动：

[2,3,1] -> [1,2,3]

因此完全可以将移动位数超过数组长度中数组长度的整数倍的去掉。也就是将移动位数对数组长度 **取 % 运算**。

#### 算法实现-Python

```python
class Solution:
    def rotate(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: void Do not return anything, modify nums in-place instead.
        """
        n = len(nums)
        nums.reverse()
        k = k%n
        self.my_reverse(nums, k, n-1)
        self.my_reverse(nums, 0, k-1)
    def my_reverse(self, nums, i, j):
        while(i<j):
            nums[i], nums[j] = nums[j], nums[i]
            i += 1
            j -= 1
```

#### 算法性能分析

- 时间复杂度：O(n)
- 空间复杂度：O(1)

### 方法二

除了按照上面的顺序逆转三次数组之外还可以按照下面的顺序来逆转数组：

- 先逆转后 k 个元素：nums[n-k,n-1]
- 再逆转前 n-k 个元素：nums[0,n-k-1]
- 最后将整个数组从头到尾逆转一遍：nums[0,n-1]

#### 算法实现-Java

```java
class Solution{
    public void rotate(int[] nums,int k){
        int n = nums.length;
        k = k%n;
        // 特殊情况判断
        if(n<2 || k==0){
            return;
        }
        // 逆序后k个
        reverse(nums,n-k,n-1);
        // 逆序前n-k个
        reverse(nums,0,n-k-1);
        // 逆序全部
        reverse(nums,0,n-1);
    }
    private void reverse(int[] nums,int start,int end){
        while(start < end){
            swap(nums,start,end);
            start++;
            end--;
        }
    }
    private void swap(int[] nums,int m,int n){
        int temp = nums[m];
        nums[m] = nums[n];
        nums[n] = temp;
    }
}
```

#### 算法性能分析

- 时间复杂度：O(n)
- 空间复杂度：O(1)

### 方法三

还有一种方式是直接将数组后 k 个元素与前 n-k 个元素一起组成新的数组，这种方式使用 python 的数组切片实现

#### 算法实现-python

```py
class Solution:
    def rotate(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: void Do not return anything, modify nums in-place instead.
        """
        n = len(nums)
        k = k%n
        nums[0:n] = nums[n-k:] + nums[:n-k]
```

#### 算法性能分析

- 时间复杂度：O(n)
- 空间复杂度：O(1)

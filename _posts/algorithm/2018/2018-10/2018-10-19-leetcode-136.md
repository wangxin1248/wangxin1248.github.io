---
layout: post
title:  "LeetCode 136. Single Number"
date:  2018-10-19
desc: "LeetCode 题目之 136. Single Number"
keywords: "LeetCode,刷题,算法,Python,LeetCode,136. Single Number"
categories: [Algorithm]
tags: [LeetCode,算法,Python]
---
# Single Number

## 问题描述

Given a non-empty array of integers, every element appears twice except for one. Find that single one.

Note:

Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?

Example 1:

```s
Input: [2,2,1]
Output: 1
Example 2:

Input: [4,1,2,1,2]
Output: 4
```

来源：[力扣（LeetCode）](https://leetcode-cn.com/problems/single-number)

## 解题思路

### 方法一：位运算

做这道题首先需要一些简单的计算机基础，假如需要具有线性时间复杂度并且还不能使用额外的空间来实现这道题的话，就得找一些比较巧妙的算法。对于这道题来说，其实就是考 **位运算**

位运算是属于算法中用到次数较多的运算，一般来说比较具有技巧性。主要的位运算包含：与、或、异或

基本的位运算知识：

- 与运算（&）
  - 0 & 0 = 0
  - 1 & 1 = 1
  - 1 & 0 = 0
- 或运算（\|）
  - 0 \| 0 = 0
  - 1 \| 0 = 1
  - 1 \| 1 = 1
- 异或运算（^）
  - 1 ^ 1 = 0
  - 1 ^ 0 = 1
  - 0 ^ 0 = 0

根据上面的知识我们可以知道：**两个相同的数异或的结果为0，而0与任何一个数异或的结果为这个数**

根据这个知识点我们便可以来求解这道题。让一个 0 开始与数组中的第一个数异或，之后将异或结果继续与下一个数进行异或，这样直到数组中所有的数都被便利完，最后的结果变为那个没有重复的数。

#### 算法实现-Python

```python
class Solution:
    def singleNumber(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        j = 0
        for i in nums:
            j ^= i
        return j
```

#### 算法实现-Java

```java
class Solution {
    public int singleNumber(int[] nums) {
        int res = 0;
        for(int i=0;i<nums.length;i++){
            res ^= nums[i];
        }
        return res;
    }
}
```

#### 算法性能分析

- 时间复杂度：O(n)
- 空间复杂度：O(1)

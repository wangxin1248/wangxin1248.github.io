---
layout: post
title:  "LeetCode 1.两数之和"
date:  2018-10-24
desc: "LeetCode 题目之 1.两数之和"
keywords: "LeetCode,刷题,算法,Python,LeetCode,两数之和"
categories: [Algorithm]
tags: [LeetCode,算法,Python]
---
# 1.两数之和

## 题目描述

给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。

你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。

示例:

给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]<br/>

## 解题思路

### 方法一：暴力求解

可以简单的用一个双重 for 循环来便利每一个可能，将所有的可能结果相加看能否和 target 的值相等。

#### 算法性能分析

- 时间复杂度：O(n^2)
- 空间复杂度：O(1)

这种方法的时间复杂度过高，因此肯定不是这道题的正确解法

### 方法二：排序+对撞指针

其实可以首先对数组进行排序的预处理，排序使用快速排序的话时间复杂度为 O(nlogn)。在排序结束之后数组便为有序数组，之后再使用对撞指针 i 和 j 分别从数组的首尾两端进行遍历：

- 假如 i 和 j 角标下的元素只和等于 target 则 i 和 j 就是所要求的的结果；
- 假如 i 和 j 角标下的元素只和大于 target 则是因为 i 和 j 的和过大，因此 j--；
- 假如 i 和 j 角标下的元素只和小于 target 则是因为 i 和 j 的和过小，因此 i++；

但是这种方法有一个问题就是在对数组进行排序之后会丢失之前数组中元素的位置信息，为了解决这个问题我们使用一个单独的数组来将未排序之前的数组的位置信息进行保存，之后在对数组进行排序的时候也对位置信息数据进行相应的位置调整，这样也就将数组中的元素的位置信息保存下来了。

#### 算法实现-Java

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        int[] ans = new int[2];
        // 记录当前数组的位置信息
        int[] locs = new int[nums.length];
        for(int i = 0; i < nums.length; i++){
            locs[i] = i;
        }
        // 对数组进行排序
        quickSort(nums, locs, 0, nums.length-1);
        // 使用对撞指针求解
        int i = 0;
        int j = nums.length-1;
        while(i < j){
            if(nums[i]+nums[j] == target){
                ans[0] = locs[i];
                ans[1] = locs[j];
                return ans;
            }else if(nums[i]+nums[j] < target){
                i++;
            }else{
                j--;
            }
        }
        return ans;
    }
    /**
    * 保存位置信息的快速排序
    */
    public void quickSort(int[] nums, int[] locs, int start, int end){
        if(start < end){
            int i = start;
            int j = end;
            int temp = nums[i];
            int loctemp = locs[i];
            while(i<j){
                while(i<j && nums[j] >= temp) j--;
                if(i<j){
                    nums[i] = nums[j];
                    locs[i] = locs[j];
                    i++;
                }
                while(i<j&&temp > nums[i]) i++;
                if(i<j){
                    nums[j] = nums[i];
                    locs[j] = locs[i];
                    j--;
                }
            }
            nums[i] = temp;
            locs[i] = loctemp;
            quickSort(nums, locs, start, i-1);
            quickSort(nums, locs, i+1, end);
        }
    }
}
```

#### 算法性能分析

- 时间复杂度：O(nlogn)
- 空间复杂度：O(n)

### 方法三：查找表


其实还可以利用 map 来求解这道问题，map 是一种包含键以及对应的值的一种数据结构。

我们可以 **将数组中所给元素的每一个元素与目标值的差值做为键，对应的值为元素的角标**，这样这便利数组的过程中，将数组的角标和角标下对应值都取出来，与字典查询该元素是否在字典中，不在则将该值与 target 的差值存入字典，值为角标。因为是两数之和，所以当便利到某个元素存在字典中的时候，那么第一个数其实已经在数组中了，和这个数之和就是 target，将该数在字典中的值和该数的角标组成新的数组返回即可。

#### 算法实现-Python

```py
class Solution(object):
    def twoSum(self, nums, target):
        dic = {}
        for i, num in enumerate(nums):
            if num in dic:
                return [dic[num], i]
            else:
                dic[target - num] = i
```

#### 算法实现-Java

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        int[] ans = new int[2];
        Map<Integer, Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            if(map.containsKey(nums[i])){
                ans[0] = map.get(nums[i]);
                ans[1] = i;
                return ans;
            }
            map.put(target-nums[i], i);
        }
        return ans;
    }
}
```

#### 算法性能分析

- 时间复杂度：O(n)
- 空间复杂度：O(n)
---
layout: post
title:  "LeetCode 13. Roman to Integer"
date:  2018-10-15
desc: "LeetCode 题目之 13. Roman to Integer"
keywords: "LeetCode,刷题,算法,C++,13. Roman to Integer"
categories: [Algorithm]
tags: [LeetCode,算法,C++]
---
# Roman to Integer

## 题目描述

Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.

Symbol       Value
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
For example, two is written as II in Roman numeral, just two one's added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.

Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:

- I can be placed before V (5) and X (10) to make 4 and 9. 
- X can be placed before L (50) and C (100) to make 40 and 90. 
- C can be placed before D (500) and M (1000) to make 400 and 900.

Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.

Example 1:

```s
Input: "III"
Output: 3
```

Example 2:

```s
Input: "IV"
Output: 4
```

Example 3:

```s
Input: "IX"
Output: 9
```

Example 4:

```s
Input: "LVIII"
Output: 58
Explanation: L = 50, V= 5, III = 3.
```

Example 5:

```s
Input: "MCMXCIV"
Output: 1994
Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.
```

来源：[力扣（LeetCode）](https://leetcode-cn.com/problems/roman-to-integer)

## 解题思路

### 方法一：从前往后判断

这道题看似比较复杂，但其实仔细想一下，也就是简单的条件判断类的题目。

依次将字符串的每一个字符都遍历一遍，分别判断他们是否是指定的这7个字符，是的话就加上对应的取值。但是其中有三组比较特别的组合是需要单独进行判断的：

- 第一个字符为 I 的话判断第二个字符是否为 V 或 X
- 第一个字符为 X 的话判断第二个字符是否为 L 或 C
- 第一个字符为 C 的话判断第二个字符是否为 D 或 M

将这几个字符进行单独判断就可以了。

注意，在判断特殊组合的时候要注意进行判断的条件是 **后面还有字符，也就是当前的角标加一得小于字符串的长度**，还得知道假如判断是特殊组合的话是需要加上特殊组合所对应的数字，而在加上特殊组合所对应的数字之后还得让 **角标自增并退出此轮循环，进入下一轮循环**。最后，将所加的值返回即可。

#### 算法实现-C++

```c++
class Solution {
public:
    int romanToInt(string s) {
        int len = s.length();
        int count = 0;
        for(int i=0;i<len;i++){
            if(s[i]=='I'){
                if((i+1)<len){
                    if(s[i+1]=='V'){
                        count += 4;
                        i += 1;
                        continue;
                    }else if(s[i+1]=='X'){
                        count += 9;
                        i += 1;
                        continue;
                    }
                }
                count += 1;
            }else if(s[i]=='V'){
                count += 5;
            }else if(s[i]=='X'){
                if((i+1)<len){
                    if(s[i+1]=='L'){
                        count += 40;
                        i += 1;
                        continue;
                    }else if(s[i+1]=='C'){
                        count += 90;
                        i += 1;
                        continue;
                    }
                }
                count += 10;
            }else if(s[i]=='L'){
                count += 50;
            }else if(s[i]=='C'){
                if((i+1)<len){
                    if(s[i+1]=='D'){
                        count += 400;
                        i += 1;
                        continue;
                    }else if(s[i+1]=='M'){
                        count += 900;
                        i += 1;
                        continue;
                    }
                }
                count += 100;
            }else if(s[i]=='D'){
                count += 500;
            }else if(s[i]=='M'){
                count += 1000;
            }
        }
        return count;
    }
};
```

#### 算法性能分析

- O(n)
- O(1)

### 方法二：从后往前判断

可以对于特殊的罗马数字采取从后往前的方式判断，相应的加法变为减法即可

#### 算法实现-C++

```cpp
class Solution {
public:
    int romanToInt(string s) {
        int result=0;
        for(int i=0;i<s.length();i++){
            switch(s[i]){
                case 'I':
                    result += 1;
                    break;
                case 'V':
                    result += 5;
                    if(s[i-1]=='I'){
                        result -= 2;
                    }
                    break;
                case 'X':
                    result += 10;
                    if(s[i-1]=='I'){
                        result -= 2;
                    }
                    break;
                case 'L':
                    result += 50;
                    if(s[i-1]=='X'){
                        result -= 20;
                    }
                    break;
                case 'C':
                    result += 100;
                    if(s[i-1]=='X'){
                        result -= 20;
                    }
                    break;
                case 'D':
                    result += 500;
                    if(s[i-1]=='C'){
                        result -= 200;
                    }
                    break;
                case 'M':
                    result += 1000;
                    if(s[i-1]=='C'){
                        result -= 200;
                    }
                    break;
            }
        }
        return result;
    }
};
```

#### 算法实现-Java

```java
class Solution {
    public int romanToInt(String s) {
        int result = 0;
        for(int i=0;i<s.length();i++){
            switch(s.charAt(i)){
                case 'I':
                    result += 1;
                    break;
                case 'V':
                    result += 5;
                    if(i>0 && s.charAt(i-1)=='I'){
                        result -= 2;
                    }
                    break;
                case 'X':
                    result += 10;
                    if(i>0 && s.charAt(i-1)=='I'){
                        result -= 2;
                    }
                    break;
                case 'L':
                    result += 50;
                    if(i>0 && s.charAt(i-1)=='X'){
                        result -= 20;
                    }
                    break;
                case 'C':
                    result += 100;
                    if(i>0 && s.charAt(i-1)=='X'){
                        result -= 20;
                    }
                    break;
                case 'D':
                    result += 500;
                    if(i>0 && s.charAt(i-1)=='C'){
                        result -= 200;
                    }
                    break;
                case 'M':
                    result += 1000;
                    if(i>0 && s.charAt(i-1)=='C'){
                        result -= 200;
                    }
                    break;
            }
        }
        return result;
    }
}
```

#### 算法性能分析

- O(n)
- O(1)

---
layout: post
title:  "LeetCode 122. Best Time to Buy and Sell Stock II"
date:  2018-10-29
desc: "LeetCode 题目之 122. Best Time to Buy and Sell Stock II"
keywords: "LeetCode,刷题,算法,Python,LeetCode,122. Best Time to Buy and Sell Stock II"
categories: [Algorithm]
tags: [LeetCode,算法,Python]
---
# Best Time to Buy and Sell Stock II

## 题目描述

Say you have an array prices for which the ith element is the price of a given stock on day i.

Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).

Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).

Example 1:

```s
Input: [7,1,5,3,6,4]
Output: 7
Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.
             Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.
```

Example 2:

```s
Input: [1,2,3,4,5]
Output: 4
Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.
             Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are
             engaging multiple transactions at the same time. You must sell before buying again.
```

Example 3:

```s
Input: [7,6,4,3,1]
Output: 0
Explanation: In this case, no transaction is done, i.e. max profit = 0.
 

Constraints:

1 <= prices.length <= 3 * 10 ^ 4
0 <= prices[i] <= 10 ^ 4
```

来源：[力扣（LeetCode）](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii)

## 解题思路

### 方法一：动态规划

本题是股票系列问题之一，按照[股票问题的通用解决方法](https://wangxin1248.github.io/algorithm/2020/05/leetcode-stock.html)可以很快的写出对应的解法。

#### 算法实现-Java

```java
class Solution {
    public int maxProfit(int[] prices) {
        int n = prices.length;
        // 初始状态取值
        int dp_i_0 = 0;//第1天没有持有股票的利润
        int dp_i_1 = Integer.MIN_VALUE;//第1天持有股票的利润（初始为负无穷）
        // 开始进行状态转移
        for(int i=0;i<n;i++){
            // 记录第i-1天没有持有股票的利润
            int temp = dp_i_0;
            // 第i天没有持有股票的最大利润=max(第i-1天也没有持有股票,第i-1天持有股票，今天卖掉了)
            dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);
            // 第i天持有股票的最大利润=max(第i-1天持有股票,第i-1天没有持有股票，今天买了)
            dp_i_1 = Math.max(dp_i_1, temp - prices[i]);
        }
        // 返回最后一天没有持有股票的利润
        return dp_i_0;
    }
}
```

#### 算法性能分析

- 时间复杂度：O(n)
- 空间复杂度：O(1)

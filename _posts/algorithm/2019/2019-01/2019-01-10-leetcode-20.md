---
layout: post
title:  "LeetCode 20. Valid Parentheses"
date:  2019-01-10
desc: "LeetCode 题目之 20. Valid Parentheses"
keywords: "LeetCode,刷题算法,c++,20. Valid Parentheses"
categories: [Algorithm]
tags: [LeetCode,算法,C++]
---
# Valid Parentheses

## 题目描述

Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.

An input string is valid if:

- Open brackets must be closed by the same type of brackets.
- Open brackets must be closed in the correct order.
- Note that an empty string is also considered valid.

Example 1:

```s
Input: "()"
Output: true
```

Example 2:

```s
Input: "()[]{}"
Output: true
```

Example 3:

```s
Input: "(]"
Output: false
```

Example 4:

```s
Input: "([)]"
Output: false
```

Example 5:

```s
Input: "{[]}"
Output: true
```

来源：[力扣（LeetCode）](https://leetcode-cn.com/problems/valid-parentheses)

## 解题思路

### 方法一：栈

这是一道考察**栈**应用的题目，对于括号匹配类的题目基本都是使用栈来解决：遇到括号的左半边入栈，遇到匹配的右括号时出栈，最终依据栈是否为空来判断括号是否匹配。

如果按照上面的思路写出一个 **switch-case** 的代码来提交会发现用时太长，因此需要对代码进行精简操作。

- 首次，( [ { 遇到这三种符号都是入栈处理，可以归为一种情况
- 假如到遇到 ) ] } 这三种符号时栈中没有元素，直接返回 false
    - 遇到 ) 时栈中元素不是 ( 直接返回 false
    - 遇到 ] 时栈中元素不是 [ 直接返回 false
    - 遇到 } 时栈中元素不是 { 直接返回 false
- 最后只需要返回栈是否为空即可

#### 算法实现-C++

```cpp
#include <stack>
class Solution {
public:
    bool isValid(string s) {
        stack<char> s1;
        for(int i=0;i<s.size();++i){
            if(s[i]=='(' || s[i]=='[' || s[i]=='{'){
                s1.push(s[i]);
            }else{
                if(s1.empty()) return false;
                if(s[i]==')' && s1.top()!='(') return false;
                if(s[i]==']' && s1.top()!='[') return false;
                if(s[i]=='}' && s1.top()!='{') return false;
                s1.pop();
            }
        }
        return s1.empty();
    }
};
```

#### 算法实现-Java

```java
class Solution{
    public boolean isValid(String s){
        // 特殊情况
        if(s.equals("")){
            return true;
        }
        // 创建栈
        Stack<Character> stack = new Stack<Character>();
        // 遍历字符串
        for(int i=0;i<s.length();i++){
            char c = s.charAt(i);
            if(c=='('||c=='['||c=='{'){
                stack.push(c);
            }else{
                if(stack.empty()){
                    return false;
                }
                if(c==')' && stack.peek() != '('){
                    return false;
                }
                if(c==']' && stack.peek() != '['){
                    return false;
                }
                if(c=='}' && stack.peek() != '{'){
                    return false;
                }
                stack.pop();
            }
        }
        return stack.empty();
    }
}
```

#### 算法性能分析

- 时间复杂度：O(n)
- 空间复杂度：O(n)

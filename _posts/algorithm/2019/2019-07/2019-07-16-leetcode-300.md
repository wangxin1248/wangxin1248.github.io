---
layout: post
title:  "LeetCode 300. Longest Increasing Subsequence"
date:  2019-07-16
desc: "LeetCode 题目之 300. Longest Increasing Subsequence"
keywords: "LeetCode,刷题算法,C++,300. Longest Increasing Subsequence"
categories: [Algorithm]
tags: [LeetCode,算法,C++]
---
# Longest Increasing Subsequence

## 题目描述

Given an unsorted array of integers, find the length of longest increasing subsequence.

Example:

```s
Input: [10,9,2,5,3,7,101,18]
Output: 4
Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.
```

Note:

- There may be more than one LIS combination, it is only necessary for you to return the length.
- Your algorithm should run in O(n2) complexity.
- Follow up: Could you improve it to O(n log n) time complexity?

来源：[力扣（LeetCode）](https://leetcode-cn.com/problems/longest-increasing-subsequence)

## 解题思路

### 方法一：动态规划

这是一道 LIS（最长上升子序列）问题，属于动态规划问题。

我们首先定义对应的状态：

```java
lis(i)：表示以第i个数字为结尾的最长上升子序列的长度
```

那么对应的状态转移方程可以表示为：

```java
lis(i) = max(1+lis(j) if nums[i] > nums[j])
         j<i
```

上面的状态转移方程可以表示为：以 i 结尾的最长上升子序列的值就是 i 之前所有比他小的元素为结尾的最长上升子序列的值+1中的最大值。（因为在 i 之前比 i 小的最长上升子序列刚好加上 i 位置的元素就构成了新的最长上升子序列）

在明确了具体的状态转移方程之后就可以开始实现了：

#### 算法实现-C++

```cpp
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int n = nums.size();
        // 特殊情况处理
        if(n==0) return 0;
        vector<int> dp = vector(n,0);
        dp[0] = 1;
        int max_res = 1;
        // 开始填表
        for(int i = 1;i<n;i++){
            int max_tem = 0;
            for(int j=0;j<i;j++){
                // 得找到之前比自己小的才寻找其中最大的dp值
                if(nums[j]<nums[i]){
                    max_tem = max(max_tem, dp[j]);
                }
            }
            max_tem++;
            dp[i] = max_tem;
            max_res = max(max_res, max_tem);
        }
        // 返回结果
        return max_res;
    }
};
```

#### 算法实现-Java

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        // 获取序列长度
        int n = nums.length;
        // 非法情况验证
        if(n < 1){
            return 0;
        }
        // 创建dp数组，初始状态每个元素的最长上升子序列都是1
        int[] dp = new int[n];
        Arrays.fill(dp,1);
        // 开始进行状态转移
        for(int i=1;i<n;i++){
            for(int j=0;j<i;j++){
                if(nums[i]>nums[j]){
                    dp[i] = Math.max(dp[i],dp[j]+1);
                }
            }
        }
        // 遍历所有的结果来寻找最大值
        int res = 1;
        for(int i=0;i<n;i++){
            res = Math.max(res,dp[i]);
        }
        // 返回最终结果
        return res;
    }
}
```

#### 算法性能分析

- 时间复杂度：O(n^2)
- 空间复杂度：O(n)

### 方法二：动态规划优化

上面的代码的时间复杂度为 O(n^2)，为了达到题目要求的 O(nlogn) 还得继续优化。

目前动态规划的思路是确定的，也就是得使用 dp 数组来保存结果，上面的代码为了找到结果是在进行了一次 for 循环，可以考虑优化这个部分。上面的代码进行 for 循环的目的是为了寻找到当前元素之前的元素中比自己小的中最大的那个元素的 dp 数组值，这里的 **dp 数组保存的是最长递增子序列的长度**，所以需要不断的遍历之前的 dp 数组的值。但是，除了保存每一个元素所对应的最长递增子序列的长度外我们可以考虑用 **dp 数组直接保存整个数组中的最长子序列的那个序列本身**，这样就不用重复遍历 dp 数组了。

也就是说对于动态规划问题来说，**确定dp数组用来保存什么内容**是非常关键的。

dp 数组用来保存数组所对应的递增子序列本身。这种情况下，dp 数组保存的元素是**递增**的，所以要将一个新的元素插入到数组的时候可以使用**二分查找**来寻找该元素的插入位置。这样时间复杂度就是 O(nlogn)，循环 n 次，每次二分查找的时间复杂度为 logn。

为了保证 dp 数组插入元素的顺序满足有序的，需要一个位置角标 res 来指向当前 dp 数组中需要插入元素的位置。假如需要插入的元素不再该 res 位置插入，则重新寻找下一个元素看其是否满足在 res 位置插入。找到元素的话则 res++，最后程序返回 res。

#### 算法实现-C++

```cpp
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int n = nums.size();
        if(n==0) return 0;
        // dp数组用来保存递增的子序列
        vector<int> dp = vector(n,0);
        // 记录递增子序列的长度
        int res = 0;
        for(int num : nums){
            int low = 0;
            int high = res;
            // 二分查找当前元素在dp数组中的位置[low,high)
            while(low<high){
                int mid = low+(high-low)/2;
                if(num > dp[mid]){
                    low = mid+1;
                }else{
                    high = mid;
                }
            }
            // 找到插入位置
            dp[low] = num;
            // 当前插入位置满足递增序列要求则将该元素保存在此位置
            if(low == res){
                res++;
            }
        }
        return res;
    }
};
```

#### 算法实现-Java

```java
class Solution{
    public int lengthOfLIS(int[] nums){
        int n = nums.length;
        // 特殊情况
        if(n==0) return 0;
        // 创建dp数组
        int[] dp = new int[n];
        // 数组存储的角标
        int res = 0;
        // 将nums中的元素存入到dp数组中
        for(int num:nums){
            // 使用二分查找在dp数组中寻找当前num合适的插入位置
            int low = 0;
            int high = res;
            while(low < high){
                int mid = low+(high-low)/2;
                if(dp[mid] < num){
                    low = mid+1;
                }else{
                    high = mid;
                }
            }
            dp[low] = num;
            if(low == res){
                res++;
            }
        }
        // 返回res即为最终结果
        return res;
    }
}
```

#### 算法性能分析

- 时间复杂度：O(nlogn)
- 空间复杂度：O(n)

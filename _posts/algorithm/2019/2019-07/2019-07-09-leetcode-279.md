---
layout: post
title:  "LeetCode 279. Perfect Squares"
date:  2019-07-09
desc: "LeetCode 题目之 279. Perfect Squares"
keywords: "LeetCode,刷题算法,C++,279. Perfect Squares"
categories: [Algorithm]
tags: [LeetCode,算法,C++]
---
# Perfect Squares

## 题目描述

Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum to n.

Example 1:

```s
Input: n = 12
Output: 3 
Explanation: 12 = 4 + 4 + 4.
```

Example 2:

```
Input: n = 13
Output: 2
Explanation: 13 = 4 + 9.
```

来源：[力扣（LeetCode）](https://leetcode-cn.com/problems/perfect-squares)

## 解题思路

### 方法一：动态规划

使用 **动态规划** 求解

可以按照三步走进行：

1.什么问题？

组成一个数完全平方和的个数；

2.使用什么数据结构？

由于计算当前数的过程中需要用到之前的数据，因此使用一维数组来存储；

3.递推公式

```s
dp[i+j*j] = min(dp[i+j*j],dp[i]+1)
初始状态为：dp[0] = 0
```

#### 算法实现-C++

```cpp
class Solution {
public:
    int numSquares(int n) {
        vector<int> dp(n+1, INT_MAX);
        dp[0] = 0;
        for(int i=0;i<=n;i++){
            for(int j=1;i+j*j<=n;j++){
                dp[i+j*j] = min(dp[i+j*j],dp[i]+1);
            }
        }
        return dp.back();
    }
};
```

#### 算法性能分析

- 时间复杂度：O(nlogn)
- 空间复杂度：O(n)

### 方法二：图

整个问题其实可以转换为一个图论问题：

- 从n到0，每个数字表示一个节点。
- 如果两个数字x和y相差一个完全平方数，则连接一条边。
- 这样就得到了一个无权图。
- 原问题就转换为求这个无权图中从n到0的**最短路径**。
- 可以通过**广度优先遍历**求解该图论问题。

#### 算法实现-Java

```java
// 存入队列中节点的结构
class Node{
    int num;// 当前数字
    int n;// 该数字距离n的步数
    Node(int num,int n){
        this.num = num;
        this.n = n;
    }
}
class Solution{
    public int numSquares(int n) {
        Queue<Node> q = new LinkedList<>();
        int[] visited = new int[n+1];
        visited[n] = 1;
        // 初始化节点入队列
        q.offer(new Node(n,0));
        // 开始进行广度优先搜索
        while(!q.isEmpty()){
            // 获取当前队列中第一个节点的数据
            int num = q.peek().num;
            int step = q.peek().n;
            q.poll();
            // 将剩余节点继续存入队列
            for(int i=1;;i++){
                // 优化变量重复计算，将循环判断条件放在循环中
                int a = num-i*i;
                if(a < 0){
                    break;
                }
                //  当a为0则已经找到解了，可以直接返回当前的step+1
                if(a == 0){
                    return step+1;
                }
                // 当前节点没有被访问的话则进行访问并进队列
                if(visited[a] ==0 ){
                    q.offer(new Node(a,step+1));
                    visited[a] = 1;
                }
            }
        }
        return 0;
    }
}
```

#### 算法性能分析

- 时间复杂度：O(n)
- 空间复杂度：O(n)

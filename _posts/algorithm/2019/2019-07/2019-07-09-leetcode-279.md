---
layout: post
title:  "LeetCode 279. Perfect Squares"
date:  2019-07-09
desc: "LeetCode 题目之 279. Perfect Squares"
keywords: "LeetCode,刷题算法,C++,279. Perfect Squares"
categories: [Algorithm]
tags: [LeetCode,算法,C++]
---
# Perfect Squares

## 题目描述

Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum to n.

Example 1:

```s
Input: n = 12
Output: 3 
Explanation: 12 = 4 + 4 + 4.
```

Example 2:

```
Input: n = 13
Output: 2
Explanation: 13 = 4 + 9.
```

来源：[力扣（LeetCode）](https://leetcode-cn.com/problems/perfect-squares)

## 解题思路

### 方法一：动态规划

本题需要我们将一个数字分为多个完全平方数组成，首先可以画出示例的递归树结构：

![2](/assets/images/2019/2019-07/02.png)

上面只画出了这颗递归树的一部分，可以看到 12 最少可以由 4+4+4 组成。

通过观察这颗递归树可以发现其中包含很多的重叠子问题。而这些重叠子问题只要找出这些子问题所对应的最小的完全平方数组成加1就是原问题的答案。因此这些重叠子问题也是最优子问题。因此我们使用**动态规划**的方法来求解。

我们使用 dp 数组来保存所有子问题的最优解。其中初始化 dp[0] = 0，其他的值设置为 int 的最大值。

然后对于每一位数字，其加上一个完全平方数的结果就是通过如下的递推公式决定的：

```s
dp[i+j*j] = min(dp[i+j*j],dp[i]+1)
```

#### 算法实现-C++

```cpp
class Solution {
public:
    int numSquares(int n) {
        vector<int> dp(n+1, INT_MAX);
        dp[0] = 0;
        for(int i=0;i<=n;i++){
            for(int j=1;i+j*j<=n;j++){
                dp[i+j*j] = min(dp[i+j*j],dp[i]+1);
            }
        }
        return dp.back();
    }
};
```

#### 算法实现-Java

除了可以像上面那样实现，还可以现将 dp[i] 初始化为 i，即每个数字最多可以由 1+1+1+...+1 组成。然后在进行优化。每次和 i-j*j 下的元素+1 进行比较，选出最小的。

```java
class Solution {
    public int numSquares(int n) {
        int[] dp = new int[n+1];
        for(int i=0;i<=n;i++){
            dp[i] = i;
            for(int j=1;i-j*j>=0;j++){
                dp[i] = Math.min(dp[i],dp[i-j*j]+1);
            }
        }
        return dp[n];
    }
}
```

#### 算法性能分析

- 时间复杂度：O(nlogn)
- 空间复杂度：O(n)

### 方法二：图

整个问题其实可以转换为一个图论问题：

- 从n到0，每个数字表示一个节点。
- 如果两个数字x和y相差一个完全平方数，则连接一条边。
- 这样就得到了一个无权图。
- 原问题就转换为求这个无权图中从n到0的**最短路径**。
- 可以通过**广度优先遍历**求解该图论问题。

#### 算法实现-Java

```java
// 存入队列中节点的结构
class Node{
    int num;// 当前数字
    int n;// 该数字距离n的步数
    Node(int num,int n){
        this.num = num;
        this.n = n;
    }
}
class Solution{
    public int numSquares(int n) {
        Queue<Node> q = new LinkedList<>();
        int[] visited = new int[n+1];
        visited[n] = 1;
        // 初始化节点入队列
        q.offer(new Node(n,0));
        // 开始进行广度优先搜索
        while(!q.isEmpty()){
            // 获取当前队列中第一个节点的数据
            int num = q.peek().num;
            int step = q.peek().n;
            q.poll();
            // 将剩余节点继续存入队列
            for(int i=1;;i++){
                // 优化变量重复计算，将循环判断条件放在循环中
                int a = num-i*i;
                if(a < 0){
                    break;
                }
                //  当a为0则已经找到解了，可以直接返回当前的step+1
                if(a == 0){
                    return step+1;
                }
                // 当前节点没有被访问的话则进行访问并进队列
                if(visited[a] ==0 ){
                    q.offer(new Node(a,step+1));
                    visited[a] = 1;
                }
            }
        }
        return 0;
    }
}
```

#### 算法性能分析

- 时间复杂度：O(n)
- 空间复杂度：O(n)

---
layout: post
title:  "LeetCode 322. Coin Change"
date:  2019-07-17
desc: "LeetCode 题目之 322. Coin Change"
keywords: "LeetCode,刷题算法,C++,322. Coin Change"
categories: [Algorithm]
tags: [LeetCode,算法,C++]
---
# Coin Change

## 题目描述

You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.

Example 1:

```s
Input: coins = [1, 2, 5], amount = 11
Output: 3 
Explanation: 11 = 5 + 5 + 1
```

Example 2:

```s
Input: coins = [2], amount = 3
Output: -1
```

Note:
- You may assume that you have an infinite number of each kind of coin.

来源：[力扣（LeetCode）](https://leetcode-cn.com/problems/coin-change)

## 解题思路

### 方法一：递归

本题是需要寻找 n 个硬币来组成 amount 的最小个数，类似于**背包问题**。需要选出某些元素来装满一个指定大小的容器。

因此我们定义递归的状态：

F(amount)：表示使用 n 个硬币来装满 amount 的最小个数。

那么对应的状态转移方程为：

```java
F(amount) = Math.min(F(amount-coins[i]))+1;
```

表示为为了装满 amount 的最小个数是装满 amount-coins[i] 的最小个数（coins[i] 是所有的硬币金额）再加一。

在明确了状态以及状态之间的转移公式之后就可以来实现递归求解的代码：

#### 算法实现-Java

```java
class Solution{
    // 全局结果
    private int res = Integer.MAX_VALUE;
    public int coinChange(int[] coins, int amount){
        // 合法性判断
        if(coins.length < 1){
            return -1;
        }
        if(amount < 1){
            return 0;
        }
        // 获取硬币的个数
        int n = coins.length;
        // 递归求解
        tryCoinChange(coins, amount, 0);
        // 判断是否有解
        if(res == Integer.MAX_VALUE){
            return -1;
        }else{
            return res;
        }
    }
    // 寻找coins中组成 amount 的最小个数count
    private void tryCoinChange(int[] coins, int amount, int count){
        // 递归结束条件，找不到解
        if(amount<0){
            return;
        }
        // 递归结束条件，找到解了，更新全局结果
        if(amount == 0){
            res = Math.min(res,count);
        }
        // 递归求解
        for(int i=0;i<coins.length;i++){
            tryCoinChange(coins, amount-coins[i], count+1);
        }
    }
}
```

### 方法二：记忆化搜索

在上面的递归求解的过程中会重复计算很多的重叠子问题（上面的代码进行提交也会出现运行超时）。

对于 coins = [1, 2, 5], amount = 11 这个例子来说，画出来其所对应的递归树：

![01](/assets/images/2019/2019-07/01.png)

因此可以将这些重复计算的过程的结果进行记录：

#### 算法实现-Java

```java
class Solution{
    // 全局结果
    private int res = Integer.MAX_VALUE;
    // 记忆数组
    private int[] memo;
    public int coinChange(int[] coins, int amount){
        // 合法性判断
        if(coins.length < 1){
            return -1;
        }
        if(amount < 1){
            return 0;
        }
        // 获取硬币的个数
        int n = coins.length;
        // 初始化记忆数组
        memo = new int[amount+1];
        Arrays.fill(memo,-1);
        // 递归求解
        return tryCoinChange(coins, amount);
    }
    // 寻找coins中组成 amount 的最小个数count
    private int tryCoinChange(int[] coins, int amount){
        // 递归结束条件，找不到解
        if(amount<0){
            return -1;
        }
        // 递归结束条件，找到解了，更新全局结果
        if(amount == 0){
            return 0;
        }
        // 判断当前状态是否已经记录过了
        if(memo[amount] != -1){
            return memo[amount];
        }
        // 递归求解
        int min = Integer.MAX_VALUE;
        for(int i=0;i<coins.length;i++){
            int res = tryCoinChange(coins, amount-coins[i]);
            if(res >= 0 && res < min){
                min = res+1;
            }
        }
        memo[amount] = (min == Integer.MAX_VALUE ? -1 : min);
        return memo[amount];
    }
}
```

### 方法三：动态规划

上面实现的方式是自顶向下的，我们也可以使用自底向上的方式来求解，也就是**动态规划**。

动态规划的状态转移公式和递归的一致，只不过从 0 开始而不是从 length-1 开始：

```
memo[amount] = min(memo[amount-coins[i]])
```

memo 数组初始化的话：

```
memo[0] = 0;
```
表示对应的硬币只需要一个就可以表示。

#### 算法实现-Java

```java
class Solution{
    // 全局结果
    private int res = Integer.MAX_VALUE;
    // 记忆数组
    private int[] memo;
    public int coinChange(int[] coins, int amount){
        // 合法性判断
        if(coins.length < 1){
            return -1;
        }
        if(amount < 1){
            return 0;
        }
        // 获取硬币的个数
        int n = coins.length;
        // 初始化记忆数组
        memo = new int[amount+1];
        memo[0] = 0;
        // 开始进行状态转移
        for(int i=1;i<=amount;i++){
            // 整个状态下的最优解
            int min = Integer.MAX_VALUE;
            // 遍历所有可能的状态
            for(int j=0;j<n;j++){
                // 当前的硬币可以组成amount则进行更新
                if(i>=coins[j] && memo[i-coins[j]]<min){
                    min = memo[i-coins[j]]+1;
                }
            }
            // 保存结果
            memo[i] = min;
        }
        // 返回最终解
        return memo[amount] == Integer.MAX_VALUE?-1:memo[amount];
    }
}
```

#### 算法实现-C++

```cpp
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        // 特殊情况
        if(amount==0) return 0;
        // 初始化dp数组
        vector<int> dp = vector(amount+1, -1);
        for(int coin : coins){
            if(coin<=amount) dp[coin] = 1;
        }
        dp[0] = 0;
        // 开始使用递推公式填dp数组
        for(int i=1;i<=amount;i++){
            if(dp[i] != -1) continue;
            int loc = INT_MAX;
            // 每次从可能的结果中选择最小的
            for(int coin : coins){
                int a = INT_MAX;
                if((i-coin) >= 0 && dp[i-coin] != -1) a = dp[i-coin]+1;
                loc = min(loc, a);
            }
            // 找到最小的才进行更新
            if(loc < INT_MAX) dp[i] = loc;
        }
        // 返回结果
        return dp[amount];
    }
};
```
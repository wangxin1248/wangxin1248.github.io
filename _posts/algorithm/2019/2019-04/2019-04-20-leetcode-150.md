---
layout: post
title:  "LeetCode 150. Evaluate Reverse Polish Notation"
date:  2019-04-20
desc: "LeetCode 题目之 150. Evaluate Reverse Polish Notation"
keywords: "LeetCode,刷题算法,C++,150. Evaluate Reverse Polish Notation"
categories: [Algorithm]
tags: [LeetCode,算法,C++]
---
# Evaluate Reverse Polish Notation

## 题目描述

Evaluate the value of an arithmetic expression in Reverse Polish Notation.

Valid operators are +, -, *, /. Each operand may be an integer or another expression.

Note:

- Division between two integers should truncate toward zero.
- The given RPN expression is always valid. That means the expression would always evaluate to a result and there won't be any divide by zero operation.

Example 1:

```s
Input: ["2", "1", "+", "3", "*"]
Output: 9
Explanation: ((2 + 1) * 3) = 9
```

Example 2:

```s
Input: ["4", "13", "5", "/", "+"]
Output: 6
Explanation: (4 + (13 / 5)) = 6
```

Example 3:

```s
Input: ["10", "6", "9", "3", "+", "-11", "*", "/", "*", "17", "+", "5", "+"]
Output: 22
Explanation: 
  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5
= ((10 * (6 / (12 * -11))) + 17) + 5
= ((10 * (6 / -132)) + 17) + 5
= ((10 * 0) + 17) + 5
= (0 + 17) + 5
= 17 + 5
= 22
```

来源：[力扣（LeetCode）](https://leetcode-cn.com/problems/evaluate-reverse-polish-notation)

## 解题思路

###  方法一：栈

逆波兰表达式计算的规则是：

- 遇到数字入栈；
- 遇到操作符出栈两个数字，将两个数字按照操作符进行计算，将计算结果保存到栈中；
- 最后保存在栈中的数字就是逆波兰表达式的结果。

#### 算法实现-C++

```cpp
class Solution {
public:
    int evalRPN(vector<string>& tokens) {
        stack<int> nums;
        for(string token : tokens){
            if(token == "+"){
                int a = nums.top();
                nums.pop();
                int b = nums.top();
                nums.pop();
                nums.push(a+b);
            }else if(token == "-"){
                int a = nums.top();
                nums.pop();
                int b = nums.top();
                nums.pop();
                nums.push(b-a);
            }else if(token == "*"){
                int a = nums.top();
                nums.pop();
                int b = nums.top();
                nums.pop();
                nums.push(b*a);
            }else if(token == "/"){
                int a = nums.top();
                nums.pop();
                int b = nums.top();
                nums.pop();
                nums.push(b/a);
            }else{
                nums.push(atoi(token.c_str()));
            }
        }
        return nums.top();
    }
};
```

#### 算法实现-Java

```java
class Solution{
    public int evalRPN(String[] tokens){
        // 创建栈
        Stack<Integer> stack = new Stack<Integer>();
        // 遍历字符，str可能为+-*/或者数字
        for(String str : tokens){
            if(str.equals("+")){
                int b = stack.pop();
                int a = stack.pop();
                stack.push(a+b);
            }else if(str.equals("-")){
                int b = stack.pop();
                int a = stack.pop();
                stack.push(a-b);
            }else if(str.equals("*")){
                int b = stack.pop();
                int a = stack.pop();
                stack.push(a*b);
            }else if(str.equals("/")){
                int b = stack.pop();
                int a = stack.pop();
                stack.push(a/b);
            }else{
                stack.push(Integer.valueOf(str));
            }
        }
        return stack.pop();
    }
}
```

#### 算法性能分析

- 时间复杂度：O(n)
- 空间复杂度：O(n)

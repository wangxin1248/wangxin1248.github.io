---
layout: post
title:  "LeetCode 341. Flatten Nested List Iterator"
date:  2019-04-20
desc: "LeetCode 题目之 341. Flatten Nested List Iterator"
keywords: "LeetCode,刷题算法,C++,341. Flatten Nested List Iterator"
categories: [Algorithm]
tags: [LeetCode,算法,C++]
---
# Flatten Nested List Iterator

## 题目描述

Given a nested list of integers, implement an iterator to flatten it.

Each element is either an integer, or a list -- whose elements may also be integers or other lists.

Example 1:

```s
Input: [[1,1],2,[1,1]]
Output: [1,1,2,1,1]
Explanation: By calling next repeatedly until hasNext returns false, 
             the order of elements returned by next should be: [1,1,2,1,1].
```

Example 2:

```s
Input: [1,[4,[6]]]
Output: [1,4,6]
Explanation: By calling next repeatedly until hasNext returns false, 
             the order of elements returned by next should be: [1,4,6].
```

来源：[力扣（LeetCode）](https://leetcode-cn.com/problems/flatten-nested-list-iterator)

## 解题思路

### 方法一：双栈

为了实现对嵌套的列表对象进行迭代我们就得使用**栈**来保存列表的嵌套结构。

由于栈是先进后出的数据结构，因此只使用一个栈的的话无法实现将数据按照原先的顺序进行输出，因此我们可以使用**双栈**来实现数据的遍历。

我们需要遍历的对象是 List<NestedInteger> nestedList，其中列表中的数据是 NestedInteger 类型的，而我们最后调用 next 方法获取到的数据是 Integer 类型的，因此我们可以首先使用一个栈来将 NestedInteger 类型的数据保存起来，然后在遍历这个栈中的元素将其存入到另一个栈中，该栈保存 Integer 类型的数据。之后调用 next 方法来每次获取栈顶元素，而 hasNext 方法只需判断当前栈是否为空即可。

#### 算法实现-C++

```cpp
class NestedIterator {
public:
	vector<int> Res;
 
	NestedIterator(vector<NestedInteger> &nestedList) {
		_NestedIterator(Res, nestedList);
	}
 
	void _NestedIterator(vector<int> &Res, vector<NestedInteger> nestedList)
	{
		for (int i = 0; i < nestedList.size(); i++)
		{
			if (nestedList[i].isInteger())
			{
				Res.push_back(nestedList[i].getInteger());
			}
			else
			{
				_NestedIterator(Res, nestedList[i].getList());
			}
		}
	}
 
 
	int next() {
		int T = Res[0];
		Res.erase(Res.begin());
		return T;
	}
 
	bool hasNext() {
		if (Res.size() != 0)
			return true;
		else
			return false;
	}
};
```

#### 算法实现-Java

```java
public class NestedIterator implements Iterator<Integer> {
    // 创建两个栈分别用来保存对应的数据
    Stack<NestedInteger> nestStack = new Stack<>();
    Stack<Integer> results = new Stack<>();

    public NestedIterator(List<NestedInteger> nestedList) {
        // 将nestedList中的NestedInteger对象入栈
        for(NestedInteger temp : nestedList){
            nestStack.push(temp);
        }
        // 将nestStack栈中的元素保存到results中
        while(!nestStack.empty()){
            NestedInteger nest = nestStack.pop();
            // 是整数则入栈results
            if(nest.isInteger()){
                results.push(nest.getInteger());
            }else{
                // 不是整数则继续遍历入栈nestStack
                List<NestedInteger> list = nest.getList();
                for(NestedInteger temp : list){
                    nestStack.push(temp);
                }
            }
        }
    }

    @Override
    public Integer next() {
        return results.pop();
    }

    @Override
    public boolean hasNext() {
        return !results.empty();
    }
}
```
---
layout: post
title:  "LeetCode 347. Top K Frequent Elements"
date:  2019-04-09
desc: "LeetCode 题目之 347. Top K Frequent Elements"
keywords: "LeetCode,刷题算法,Java,347. Top K Frequent Elements"
categories: [Algorithm]
tags: [LeetCode,算法,Java]
---
# Top K Frequent Elements

## 题目描述

Given a non-empty array of integers, return the k most frequent elements.

Example 1:

```
Input: nums = [1,1,1,2,2,3], k = 2
Output: [1,2]
```

Example 2:

```s
Input: nums = [1], k = 1
Output: [1]
```

Note:

- You may assume k is always valid, 1 ≤ k ≤ number of unique elements.
- Your algorithm's time complexity must be better than O(n log n), where n is the array's size.

## 算法实现

### 方法一：排序

可以将数组中字符及其对应出现的频率进行保存，然后按照频率进行排序，最后将排序结束之后的前 k 个元素进行输出即可。

#### 算法实现-Java

```java
import java.util.*;
class Solution {
    public List<Integer> topKFrequent(int[] nums, int k) {
        // 结果集合
        List<Integer> result = new ArrayList<Integer>();
        // 创建一个hashmap用来存储数组中出现的元素及其对应的次数
        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();
        
        // 遍历数组，将元素以及对应出现的次数保存在map中
        for(int num : nums){
            int i=0;
            if(map.get(num) != null){
                i = map.get(num);
            }
            i++;
            map.put(num, i);
        }
        
        // 将字典转换为列表
        List<Map.Entry<Integer,Integer>> list_entry = new ArrayList<Map.Entry<Integer,Integer>>(map.entrySet());

        // 将列表按照value进行排序
        Collections.sort(list_entry, new Comparator<Map.Entry<Integer,Integer>>(){
            public int compare(Map.Entry<Integer,Integer> o1, Map.Entry<Integer,Integer> o2){
                return o2.getValue()-o1.getValue();
            }
        });
        
        // 获取结果
        for(int i=0;i<k;i++){
            result.add(list_entry.get(i).getKey());
        }
        return result;
    }
}
```

#### 算法性能分析

- 时间复杂度：O(nlogn)
- 空间复杂度：O(n)

### 方法二：优先队列

可以使用优先队列来保存元素出现的次数及其对应的元素，由于优先队列底层是有**堆**数据结构实现的，因此其中保存的数据是有序的，我们只需创建一个的**小顶堆**，并且设置所要保存进堆中元素所要进行比较的比较器，这里设置比较器是按照所要保存元素的出现频率从小到大进行比较的。然后只需将元素保存到优先队列中，只要优先队列的长度超过 k，则将当前堆顶元素出队列，也就是将最小的元素出队列，这样最后队列中保存的就是当前元素中出现频率最高的前 k 个了。最后按照直到的要求返回即可。

#### 算法实现-Java

```java
class Solution{
    public List<Integer> topKFrequent(int[] nums,int k){
        int n = nums.length;
        // 保存当前数组中每一个元素的出现次数
        // key：元素，value：出现次数
        Map<Integer,Integer> map = new HashMap<>();
        for(int i : nums){
            map.put(i,map.getOrDefault(i,0)+1);
        }

        // 创建长度为k的小顶堆，保存元素，传入比较器比较元素出现的次数
        Queue<Integer> q = new PriorityQueue<>((n1,n2) -> map.get(n1)-map.get(n2));
        for(Integer key : map.keySet()){
            q.add(key);
            // 当队列长度超过k的时候将当前堆顶元素出堆（最小元素）
            if(q.size()>k){
                q.poll();
            }
        }

        // 保存结果
        List<Integer> res = new ArrayList<>();
        while(!q.isEmpty()){
            res.add(0,q.poll());
        }
        return res;
    }
}
```

#### 算法性能分析

- 时间复杂度：O(nlogk)，队列中保存k个元素需要 logk 的时间复杂度，需要进行 n 次。
- 空间复杂度：O(n)

---
layout: post
title:  "LeetCode 148. Sort List"
date:  2019-05-21
desc: "LeetCode 题目之 148. Sort List"
keywords: "LeetCode,刷题算法,C++,148. Sort List"
categories: [Algorithm]
tags: [LeetCode,算法,C++]
---
# Sort List

## 题目描述

Sort a linked list in O(n log n) time using constant space complexity.

Example 1:

```s
Input: 4->2->1->3
Output: 1->2->3->4
```

Example 2:

```s
Input: -1->5->3->4->0
Output: -1->0->3->4->5
```

来源：[力扣（LeetCode）](https://leetcode-cn.com/problems/sort-list)

## 解题思路

### 方法一：归并排序

根据题目的要求在 O(nlogn) 时间复杂度和常数级空间复杂度下对链表进行排序。

已知的排序算法中，时间复杂度为 O(nlogn) 的有快排、堆排序、归并排序。其中堆排序不适合对链表进行排序，快速排序由于是不稳定的排序，在有些情况下的时间复杂度为O(n2)。因此只能选择稳定的**归并排序**来解决这道问题。

归并排序的基本思想：**找到链表的中间节点，然后递归的对前半部分链表和后半部分链表分别进行递归排序，最后对两个子链表进行归并操作。**

因此，本题的考察点：

- 递归的应用
- 归并排序的思想
- 如何找到一个链表的中间节点
- 如何合并两个以排好序的链表为一个有序链表

对于如何获取链表的中间节点我们可以通过**快慢指针**来实现。

接下来介绍下归并排序的主要思想：

归并排序是排序算法的一种，是利用归并的思想实现的排序算法，该算法采用经典的分治策略。以数组排序为例该算法的图解如下：

![merge sort](/assets/images/2019/2019-05/15.png)

上述算法便是归并排序的图解（属于自顶向下实现），主要分别**分**和**治**两部分。分的部分首先需要将待排序数组从中间一分为二，然后继续对分割开的数组进行递归分割，直到所有的数无法分割为止；接下来是合并两个单独的数为一个整体有序的数，然后按照自顶向上的递归顺序进行自底向上的两两合并操作。最终递归完成整体的数组就成有序状态了。以上对于数组的操作对于链表同样适用。

也就是说对于归并排序来说，主要进行如下步骤的递归操作：

- 寻找中间节点将链表一分为二
- 对分割开的两个链表进行递归分割
- 将递归分割返回的节点进行归并操作

而其中归并排序最重要的是最后的**归并**操作，也就是上图中**治**的部分。继续使用图解来表示这个过程：

![merge-01](/assets/images/2019/2019-05/16.png)
![merge-02](/assets/images/2019/2019-05/17.png)

对于数组来说需要使用 i 和 j 两个指针来对于所要归并的两部分数组进行逐位的判断，将较小的放置在 temp 数组中，最后将所有的 temp 数组中的内容拷贝到原数组中。

而相同的操作对于链表来说就比较简单的，也就是简单的将两个有序链表合并为整体的一个有序链表。

#### 算法实现-C++

```cpp
class Solution {
public:
    ListNode* sortList(ListNode* head){
        return mergesort(head);
    }
    ListNode* getMid(ListNode* head){
        ListNode* slow = head;
        ListNode* fast = head;
        while(fast->next && fast->next->next){
            slow = slow->next;
            fast = fast->next->next;
        }
        return slow;
    }
    ListNode* mergesort(ListNode* node){
        if(!node || !node->next) return node;
        // 获取中间节点
        ListNode* middle = getMid(node);
        // 将链表从中间节点处断开分为两个子链表
        ListNode* nextHead = middle->next;
        middle->next = NULL;
        // 分别对两个子链表进行归并排序
        ListNode* l1 = mergesort(node);
        ListNode* l2 = mergesort(nextHead);
        // 最后对两个链表进行归并
        return merge(l1,l2);
    }
    ListNode* merge(ListNode* l1, ListNode* l2){
        if(!l1) return l2;
        if(!l2) return l1;
        if(l1->val < l2->val){
            l1->next = merge(l1->next,l2);
            return l1;
        }else{
            l2->next = merge(l2->next,l1);
            return l2;
        }
    }
};
```

#### 算法实现-Java

```java
class Solution {
    public ListNode sortList(ListNode head) {
        // 进行归并排序
        return mergeSort(head);
    }
    // 执行归并排序操作
    public ListNode mergeSort(ListNode head){
        // 特殊情况
        if(head == null || head.next == null){
            return head;
        }
        // 寻找链表的中间节点
        ListNode mid = getMid(head);

        // 将链表分割为两部分
        ListNode newHead = mid.next;
        mid.next = null;

        // 继续执行归并操作
        ListNode l1 = mergeSort(head);
        ListNode l2 = mergeSort(newHead);

        // 归并两个链表，返回最终结果
        return merge(l1,l2);
    }

    // 快慢指针寻找中间节点
    public ListNode getMid(ListNode head){
        // 特殊情况
        if(head == null || head.next == null){
            return head;
        }
        // 构建快慢指针
        ListNode slow = head;
        ListNode fast = head;
        while(fast.next != null && fast.next.next != null){
            slow = slow.next;
            fast = fast.next.next;
        }

        // 返回满指针为中间节点
        return slow;
    }

    // 归并两个链表为一个有序链表操作
    public ListNode merge(ListNode l1, ListNode l2){
        if(l1 == null){
            return l2;
        }
        if(l2 == null){
            return l1;
        }
        if(l1.val <= l2.val){
            l1.next = merge(l1.next,l2);
            return l1;
        }else{
            l2.next = merge(l1,l2.next);
            return l2;
        }
    }
}
```

#### 算法性能分析

- 时间复杂度：O(nlogn)
- 空间复杂度：O(1)

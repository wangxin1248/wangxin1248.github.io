---
layout: post
title:  "LeetCode 215. Kth Largest Element in an Array"
date:  2019-03-28
desc: "LeetCode 题目之 215. Kth Largest Element in an Array"
keywords: "LeetCode,刷题算法,Java,215. Kth Largest Element in an Array"
categories: [Algorithm]
tags: [LeetCode,算法,Java]
---
# Kth Largest Element in an Array

## 题目描述

Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.

Example 1:

```s
Input: [3,2,1,5,6,4] and k = 2
Output: 5
```

Example 2:

```
Input: [3,2,3,1,2,4,5,5,6] and k = 4
Output: 4
```

Note:
- You may assume k is always valid, 1 ≤ k ≤ array's length.

## 解题思路

### 方法一：排序

按照题目的介绍来看可以通过对数据进行冒泡排序，每次都会有一个当前最大的元素被放在最后一个位置上。这个只需要控制排序的次数便可以获取到第 k 大的元素了。但是这种方法是 O(n^2) 的，效率并不高。

#### 代码实现-Java

```java
class Solution {
    public int findKthLargest(int[] nums, int k) {
        int n = nums.length;
        for(int i=n-1;i>0;i--){
            // 冒泡排序
            for(int j=1;j<=i;j++){
                if(nums[j-1]>nums[j]){
                    nums[j-1] ^= nums[j];
                    nums[j] ^= nums[j-1];
                    nums[j-1] ^= nums[j];
                }
            }
            // 返回第k大的元素
            if(i == (n-k)){
                return nums[i];
            }
        }
        return nums[0];
    }
}
```

#### 算法性能分析

- O(n^2)
- O(1)

### 方法二：快速排序

还有另外一种方法便是使用到**快速排序**的思想。

快速排序中最重要的便是 partition 操作，即从数组中选择一个元素，将其放置在排好序的最终位置上，并返回当前位置。这个位置便是基准元素在最终排好序的数组中的位置。

那么便可以使用这个性质来找到一个随机元素的角标，然后判断他是否是第 k 大也就是第 n-k 角标下的元素。假如不是的话便继续使用快速排序递归的处理剩余部分呢。

#### 代码实现-Java

```java
class Solution{
    public int findKthLargest(int[] nums,int k){
        int n = nums.length;
        if(n<1){
            return 0;
        }
        // 递归寻找第k大的元素即角标为第n-k个元素
        // 寻找范围nums[0,...,n-1]
        return quickSort(nums,0,n-1,n-k);
    }
    public int quickSort(int[] nums,int l,int r,int k){
        if(l > r){
            return 0;
        }
        // 获取一个元素的角标
        int index = parition(nums,l,r);
        // 判断角标是否符合要求
        if(index == k){
            return nums[index];
        }else if(index > k){
            return quickSort(nums,l,index-1,k);
        }else{
            return quickSort(nums,index+1,r,k);
        }
    }
    // 寻找元素角标
    public int parition(int[] nums,int l,int r){
        // 随机选择一个元素作为基准元素
        swap(nums,l,(int)Math.random()*(r-l+1)+l);
        int v = nums[l];
        // nums[l,...,index] < v
        int index = l;
        for(int i=l+1;i<=r;i++){
            if(nums[i] < v){
                index++;
                swap(nums,i,index);
            }
        }
        // index即为基准元素的最终位置
        swap(nums,l,index);
        return index;
    }
    // 交换两个元素
    public void swap(int[] nums,int l,int r){
        int num = nums[l];
        nums[l] = nums[r];
        nums[r] = num;
    }
}
```

#### 算法性能分析

- 时间复杂度：O(n)
- 空间复杂度：O(1)

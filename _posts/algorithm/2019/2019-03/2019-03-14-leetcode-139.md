---
layout: post
title:  "LeetCode 139. Word Break"
date:  2019-03-14
desc: "LeetCode 题目之 139. Word Break"
keywords: "LeetCode,刷题算法,Java,139. Word Break"
categories: [Algorithm]
tags: [LeetCode,算法,Java]
---
# Word Break

## 题目描述

Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words.

Note:

- The same word in the dictionary may be reused multiple times in the segmentation.
- You may assume the dictionary does not contain duplicate words.

Example 1:

```s
Input: s = "leetcode", wordDict = ["leet", "code"]
Output: true
Explanation: Return true because "leetcode" can be segmented as "leet code".
```

Example 2:

```s
Input: s = "applepenapple", wordDict = ["apple", "pen"]
Output: true
Explanation: Return true because "applepenapple" can be segmented as "apple pen apple".
             Note that you are allowed to reuse a dictionary word.
```

Example 3:

```s
Input: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
Output: false
```

来源：[力扣（LeetCode）](https://leetcode-cn.com/problems/word-break)

## 解题思路

### 方法一：动态规划

我们要解决的是字符串 s 是否能够被字典中的单词来表示，这样就可以表示为“物品”（字符串 s ）是否可以装满字典当中的每一个“背包”（单词）。这是一道**背包类**的问题。

那么我们可以定义对应的状态：

```java
F(i)：表示字符串从0到 i 位置上的元素是否可以装满背包
```

那么对应的状态转移方程可以表示为：

```java
F(i) = F(j)&&s.substring(j,i+1) in dict
```

初始条件是：res[0] = true.表示第0个元素之前是可以被表示的。

#### 算法实现-Java

```java
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        // 获取字符串长度
        int n = s.length();
        // memo[i] 表示 s 中以 i - 1 结尾的字符串是否可被 wordDict 拆分
        boolean[] memo = new boolean[n + 1];
        // 初始状态设置
        memo[0] = true;
        // 开始状态转移
        for (int i = 1; i <= n; i++) {
            for (int j = 0; j < i; j++) {
                // 使用递推公式进行状态转移
                if (memo[j] && wordDict.contains(s.substring(j, i))) {
                    memo[i] = true;
                    break;
                }
            }
        }
        return memo[n];
    }
}
```

#### 算法性能分析

- 时间复杂度：O(n^2)
- 空间复杂度：O(n)

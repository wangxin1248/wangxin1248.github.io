---
layout: post
title:  "LeetCode 200. Number of Islands"
date:  2019-08-02
desc: "LeetCode 题目之 200. Number of Islands"
keywords: "LeetCode,刷题算法,C++,200. Number of Islands"
categories: [Algorithm]
tags: [LeetCode,算法,C++]
---
# Number of Islands

## 题目描述

Given a 2d grid map of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.

Example 1:

```s
Input:
11110
11010
11000
00000

Output: 1
```

Example 2:

```s
Input:
11000
11000
00100
00011

Output: 3
```

来源：[力扣（LeetCode）](https://leetcode-cn.com/problems/number-of-islands)

## 解题思路

### 方法一：floodfill

这道题是搜索所有的岛屿数量，是属于在二维平面上的搜索问题。可以使用**floodfill**方法来进行求解。

首先可以使用**深度优先遍历**来访问图中的每一个节点，只要满足如下的条件便递归的调用深度优先遍历来搜索下一个节点：

- 该节点未被访问过
- 该节点存在
- 该节点是陆地

遍历的时候选择当前节点的**上下左右**四个节点来遍历，这样便可以将同一块陆地都遍历完。

为了节省空间，可以在原图上直接修改来表示当前节点的访问状态，将访问过的节点的值变为 '0'。因为假如该节点的值是 '0'的话该节点是不会被深度搜索的，只有节点的值为 '1'才会进行深度优先搜索。这样便可以在同一个数组上表示当前节点的访问状态。

#### 算法实现-C++

```cpp
class Solution {
public:
    int numIslands(vector<vector<char>>& grid) {
        int n = grid.size();
        if(n < 1) return 0;
        int m = grid[0].size();
        int res = 0;
        // 开始深度搜索
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                // 满足条件就开始进行深度优先遍历
                if(grid[i][j]=='1'){
                    res++;
                    dfs(i,j,n,m,grid);
                }
            }
        }
        // 返回结果
        return res;
    }
    
    // 深度优先遍历搜索
    void dfs(int i, int j,int n, int m, vector<vector<char>>& grid){
        // 判断角标是否越界
        if(i<0 || j<0 || i>=n || j>=m) return;
        // 判断当前节点是否可以访问
        if(grid[i][j] == '0') return;
        // 访问该节点
        grid[i][j] = '0';
        // 开始递归上下左右节点
        dfs(i-1,j,n,m,grid);
        dfs(i+1,j,n,m,grid);
        dfs(i, j-1,n,m,grid);
        dfs(i,j+1,n,m,grid);
    }
};
```

#### 算法实现-Java

```java
class Solution{
    private int m,n;//当前搜索空间的大小
    private int[][] step = \{\{-1,0\},\{0,1\},\{1,0\},\{0,-1\}\};//上右下左移动
    public int numIslands(char[][] grid){
        int res = 0;
        m = grid.length;
        // 非法情况
        if(m<1){
            return res;
        }
        n = grid[0].length;
        
        // 开始搜索所有的位置
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(grid[i][j] == '1'){
                    res++;
                    dfs(grid,i,j);//去搜索其他的可能性
                }
            }
        }
        return res;
    }
    // 从grid[x][y]开始搜索所有的陆地
    private void dfs(char[][] grid,int x,int y){
        if(grid[x][y] == '1'){
            // 访问该点
            grid[x][y] = '0';
            // 递归寻找其他方向
            for(int i=0;i<4;i++){
                int newx = x+step[i][0];
                int newy = y+step[i][1];
                // 判断当前点是否存在
                if(inGrid(newx,newy)){
                    // 当前是岛屿
                    if(grid[newx][newy] == '1'){
                        dfs(grid,newx,newy);
                    }
                }
            }
        }
        return;
    }
    // 判断grid[x][y]是否存在
    private boolean inGrid(int x,int y){
        return x>=0 && x<m && y>= 0 && y<n;
    }
}
```

#### 算法性能分析

- 时间复杂度：O(n^2)
- 空间复杂度：O(n^2)
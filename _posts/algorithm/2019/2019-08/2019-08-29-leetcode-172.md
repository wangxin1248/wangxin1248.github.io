---
layout: post
title:  "LeetCode 172. 阶乘后的零"
date:  2019-08-29
desc: "LeetCode 题目之 172. 阶乘后的零"
keywords: "LeetCode,刷题算法,C++,172. 阶乘后的零"
categories: [Algorithm]
tags: [LeetCode,算法,C++]
---
# 阶乘后的零

## 题目描述

给定一个整数 n，返回 n! 结果尾数中零的数量。

示例 1:

```
输入: 3
输出: 0
解释: 3! = 6, 尾数中没有零。
```

示例 2:

```
输入: 5
输出: 1
解释: 5! = 120, 尾数中有 1 个零.
```

说明: 你算法的时间复杂度应为 O(log n) 。

题目链接：[https://leetcode-cn.com/problems/factorial-trailing-zeroes](https://leetcode-cn.com/problems/factorial-trailing-zeroes)

## 解题思路

这道题可以按照将每一个数多对应的阶乘计算出来在判断其0的个数来做，但是这种方式计算结果会超级大，不能通过题目。

因此，得从结果中找寻规律，以下是1～20的阶乘表：

```
1   1
2   2
3   6
4   24
5   120
6   720
7   5040
8   40320
9   362880
10  3628800
11  39916800
12  479001600
13  6227020800
14  87178291200
15  1307674368000
16  20922789888000
17  355687428096000
18  6402373705728000
19  121645100408832000
20  2432902008176640000
```

从中可以发现：在5，10，15，20所对应的阶乘结果相比较与之前的增加了一个0。

这是因为：2*5=10，不仅是2和5，凡是因子是2和5的也算，计算结果都会多出一个0。

因此，可以通过计算 n 中含有因子是2和5的个数对的个数来判断最终结果中有多少个0，又因为一个数中含有因子是5的数的个数远远小于因子是2的个数，因此只需要计算 n 中含有因子是5的个数就可以了。

### C++代码

#### 递归实现

```cpp
class Solution {
public:
    int trailingZeroes(int n) {
        return n>=5?(n/5)+trailingZeroes(n/5):0;
    }
};
```

#### 非递归实现

```cpp
class Solution{
public:
    int trailingZeroes(int n){
        int res = 0;
        while(n>=5){
            res += n/5;
            n /= 5;
        }
        return res;
    }
}
```

### 算法性能分析

- 时间复杂度：O(logn)
- 空间复杂度：O(1)